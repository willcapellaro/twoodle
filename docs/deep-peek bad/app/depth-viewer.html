<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth Map Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            height: 100vh;
            width: 100vw;
        }

        /* Main viewer container */
        #viewer-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
        }

        #viewer-container.dragging {
            cursor: grabbing;
        }

        /* Canvas for depth effect */
        #depth-canvas {
            position: absolute;
            top: 0;
            left: 0;
            background: #000;
        }

        /* Fit mode styles */
        .fit-mode #depth-canvas {
            max-width: 100vw;
            max-height: 100vh;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            object-fit: contain;
        }

        /* Fill mode styles */
        .fill-mode {
            overflow: auto;
        }

        .fill-mode #depth-canvas {
            min-width: 100vw;
            min-height: 100vh;
            object-fit: cover;
        }

        /* Drop zone overlay */
        #drop-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        #drop-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .drop-zone {
            border: 2px dashed #666;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            color: #fff;
            font-size: 18px;
        }

        .drop-zone.dragover {
            border-color: #007acc;
            background: rgba(0, 122, 204, 0.1);
        }

        /* UI Controls */
        .ui-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .ui-button {
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .ui-button:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .ui-button.active {
            background: rgba(0, 122, 204, 0.8);
            border-color: #007acc;
        }

        /* Side panel */
        .side-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 300px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 200;
            padding: 20px;
            color: #fff;
        }

        .side-panel.open {
            transform: translateX(0);
        }

        .control-group {
            margin-bottom: 24px;
        }

        .control-label {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 8px;
            display: block;
        }

        .slider {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: #007acc;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Hidden file input */
        #file-input {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Main viewer container -->
    <div id="viewer-container" class="fit-mode">
        <canvas id="depth-canvas"></canvas>
    </div>

    <!-- Drop overlay -->
    <div id="drop-overlay">
        <div class="drop-zone">
            <div>Drop color image + depth map (‚àÇmap)</div>
            <div style="font-size: 14px; margin-top: 8px; opacity: 0.7;">
                Expecting: image.jpg + image-‚àÇmap.png
            </div>
        </div>
    </div>

    <!-- UI Controls -->
    <div class="ui-controls">
        <button class="ui-button" id="fit-fill-btn" title="Toggle Fit/Fill">‚öè</button>
        <button class="ui-button" id="upload-btn" title="Upload Images">üìÅ</button>
        <button class="ui-button" id="panel-btn" title="Controls">‚ñ∂</button>
    </div>

    <!-- Side Panel -->
    <div class="side-panel" id="side-panel">
        <div class="control-group">
            <label class="control-label">Depth Intensity</label>
            <input type="range" class="slider" id="depth-intensity" min="0" max="100" value="50">
        </div>
        
        <div class="control-group">
            <label class="control-label">Focus Distance</label>
            <input type="range" class="slider" id="focus-distance" min="0" max="100" value="50">
        </div>
        
        <div class="control-group">
            <label class="control-label">Perspective</label>
            <input type="range" class="slider" id="perspective" min="0" max="100" value="50">
        </div>

        <div class="control-group">
            <label class="control-label">Quality</label>
            <input type="range" class="slider" id="quality" min="1" max="4" value="2" step="1">
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="file-input" multiple accept="image/*">

    <script>
        class DepthViewer {
            constructor() {
                this.canvas = document.getElementById('depth-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('viewer-container');
                
                this.colorImage = null;
                this.depthMap = null;
                this.viewMode = 'fit'; // 'fit' or 'fill'
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.depthOffset = { x: 0, y: 0 };
                
                this.initializeControls();
                this.setupDropZone();
                this.loadExampleImages();
            }

            initializeControls() {
                // Fit/Fill toggle
                document.getElementById('fit-fill-btn').addEventListener('click', () => {
                    this.toggleViewMode();
                });

                // Upload button
                document.getElementById('upload-btn').addEventListener('click', () => {
                    document.getElementById('file-input').click();
                });

                // Panel toggle
                document.getElementById('panel-btn').addEventListener('click', () => {
                    this.togglePanel();
                });

                // File input
                document.getElementById('file-input').addEventListener('change', (e) => {
                    this.handleFiles(Array.from(e.target.files));
                });

                // Drag interaction for depth effect
                this.canvas.addEventListener('mousedown', (e) => this.startDrag(e));
                document.addEventListener('mousemove', (e) => this.drag(e));
                document.addEventListener('mouseup', () => this.endDrag());

                // Control sliders
                document.getElementById('depth-intensity').addEventListener('input', () => this.render());
                document.getElementById('focus-distance').addEventListener('input', () => this.render());
                document.getElementById('perspective').addEventListener('input', () => this.render());
                document.getElementById('quality').addEventListener('input', () => this.render());
            }

            setupDropZone() {
                const overlay = document.getElementById('drop-overlay');
                const dropZone = overlay.querySelector('.drop-zone');

                // Prevent default drag behaviors
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    document.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });

                // Show overlay on drag enter
                document.addEventListener('dragenter', () => {
                    overlay.classList.add('active');
                });

                // Hide overlay on drag leave (when leaving the document)
                document.addEventListener('dragleave', (e) => {
                    if (!e.relatedTarget) {
                        overlay.classList.remove('active');
                    }
                });

                // Handle dragover on drop zone
                dropZone.addEventListener('dragover', () => {
                    dropZone.classList.add('dragover');
                });

                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('dragover');
                });

                // Handle drop
                document.addEventListener('drop', (e) => {
                    overlay.classList.remove('active');
                    dropZone.classList.remove('dragover');
                    
                    const files = Array.from(e.dataTransfer.files);
                    this.handleFiles(files);
                });
            }

            async loadExampleImages() {
                try {
                    // Load example images
                    const colorImg = await this.loadImageFromUrl('images/test-images/glassbutt.jpeg');
                    const depthImg = await this.loadImageFromUrl('images/test-images/glassbutt-‚àÇmap.png');
                    
                    this.colorImage = colorImg;
                    this.depthMap = depthImg;
                    this.render();
                } catch (error) {
                    console.log('Could not load example images:', error);
                }
            }

            loadImageFromUrl(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = url;
                });
            }

            handleFiles(files) {
                if (files.length === 0) return;

                const colorFile = files.find(f => !f.name.includes('‚àÇmap'));
                const depthFile = files.find(f => f.name.includes('‚àÇmap'));

                if (colorFile) {
                    this.loadImageFile(colorFile, 'color');
                }
                
                if (depthFile) {
                    this.loadImageFile(depthFile, 'depth');
                }
            }

            loadImageFile(file, type) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        if (type === 'color') {
                            this.colorImage = img;
                        } else {
                            this.depthMap = img;
                        }
                        this.render();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            toggleViewMode() {
                this.viewMode = this.viewMode === 'fit' ? 'fill' : 'fit';
                this.container.className = this.viewMode + '-mode';
                
                const btn = document.getElementById('fit-fill-btn');
                btn.classList.toggle('active', this.viewMode === 'fill');
                
                this.render();
            }

            togglePanel() {
                const panel = document.getElementById('side-panel');
                const btn = document.getElementById('panel-btn');
                
                panel.classList.toggle('open');
                btn.classList.toggle('active');
                btn.textContent = panel.classList.contains('open') ? '‚óÄ' : '‚ñ∂';
            }

            startDrag(e) {
                this.isDragging = true;
                this.dragStart = { x: e.clientX, y: e.clientY };
                this.container.classList.add('dragging');
            }

            drag(e) {
                if (!this.isDragging || !this.colorImage || !this.depthMap) return;

                const deltaX = e.clientX - this.dragStart.x;
                const deltaY = e.clientY - this.dragStart.y;

                // Convert drag distance to depth offset
                this.depthOffset.x = deltaX * 0.1;
                this.depthOffset.y = deltaY * 0.1;

                this.render();
            }

            endDrag() {
                this.isDragging = false;
                this.container.classList.remove('dragging');
            }

            render() {
                if (!this.colorImage || !this.depthMap) return;

                const containerRect = this.container.getBoundingClientRect();
                let canvasWidth, canvasHeight;

                if (this.viewMode === 'fit') {
                    // Fit mode: maintain aspect ratio, fit within viewport
                    const imgAspect = this.colorImage.width / this.colorImage.height;
                    const containerAspect = containerRect.width / containerRect.height;

                    if (imgAspect > containerAspect) {
                        canvasWidth = containerRect.width;
                        canvasHeight = containerRect.width / imgAspect;
                    } else {
                        canvasHeight = containerRect.height;
                        canvasWidth = containerRect.height * imgAspect;
                    }
                } else {
                    // Fill mode: cover entire viewport
                    const imgAspect = this.colorImage.width / this.colorImage.height;
                    const containerAspect = containerRect.width / containerRect.height;

                    if (imgAspect > containerAspect) {
                        canvasHeight = containerRect.height;
                        canvasWidth = containerRect.height * imgAspect;
                    } else {
                        canvasWidth = containerRect.width;
                        canvasHeight = containerRect.width / imgAspect;
                    }
                }

                this.canvas.width = canvasWidth;
                this.canvas.height = canvasHeight;
                this.canvas.style.width = canvasWidth + 'px';
                this.canvas.style.height = canvasHeight + 'px';

                // Apply depth effect
                this.applyDepthEffect();
            }

            applyDepthEffect() {
                // Get control values
                const intensity = document.getElementById('depth-intensity').value / 100;
                const focusDistance = document.getElementById('focus-distance').value / 100;
                const perspective = document.getElementById('perspective').value / 100;

                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Create temporary canvases for processing
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;

                // Draw base color image
                this.ctx.drawImage(this.colorImage, 0, 0, this.canvas.width, this.canvas.height);

                // If we have depth data, apply displacement effect
                if (this.depthMap && (this.depthOffset.x !== 0 || this.depthOffset.y !== 0)) {
                    // Draw depth map to temp canvas
                    tempCtx.drawImage(this.depthMap, 0, 0, this.canvas.width, this.canvas.height);
                    const depthData = tempCtx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Draw color image to temp canvas
                    tempCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    tempCtx.drawImage(this.colorImage, 0, 0, this.canvas.width, this.canvas.height);
                    const colorData = tempCtx.getImageData(0, 0, this.canvas.width, this.canvas.height);

                    // Apply depth displacement
                    const outputData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                    
                    for (let y = 0; y < this.canvas.height; y++) {
                        for (let x = 0; x < this.canvas.width; x++) {
                            const i = (y * this.canvas.width + x) * 4;
                            
                            // Get depth value (using red channel)
                            const depth = depthData.data[i] / 255;
                            
                            // Calculate displacement based on depth and drag offset
                            const displaceX = Math.round(this.depthOffset.x * depth * intensity);
                            const displaceY = Math.round(this.depthOffset.y * depth * intensity);
                            
                            // Source coordinates
                            const srcX = Math.max(0, Math.min(this.canvas.width - 1, x - displaceX));
                            const srcY = Math.max(0, Math.min(this.canvas.height - 1, y - displaceY));
                            const srcI = (srcY * this.canvas.width + srcX) * 4;
                            
                            // Copy pixel from displaced position
                            outputData.data[i] = colorData.data[srcI];         // R
                            outputData.data[i + 1] = colorData.data[srcI + 1]; // G
                            outputData.data[i + 2] = colorData.data[srcI + 2]; // B
                            outputData.data[i + 3] = colorData.data[srcI + 3]; // A
                        }
                    }
                    
                    this.ctx.putImageData(outputData, 0, 0);
                }
            }
        }

        // Initialize the depth viewer when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new DepthViewer();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (window.depthViewer) {
                window.depthViewer.render();
            }
        });
    </script>
</body>
</html>