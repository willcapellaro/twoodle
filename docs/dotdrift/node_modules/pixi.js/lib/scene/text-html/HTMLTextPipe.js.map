{"version":3,"file":"HTMLTextPipe.js","sources":["../../../src/scene/text-html/HTMLTextPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateTextBounds } from '../text/utils/updateTextBounds';\nimport { BatchableHTMLText } from './BatchableHTMLText';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The HTMLTextPipe class is responsible for rendering HTML text.\n * @internal\n */\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText.styleKey;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (htmlText._didTextUpdate)\n        {\n            const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n            if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(htmlText).catch((e) =>\n                {\n                    console.error(e);\n                });\n            }\n\n            htmlText._didTextUpdate = false;\n\n            updateTextBounds(batchableHTMLText, htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        batchableHTMLText._batcher.updateElement(batchableHTMLText);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (batchableHTMLText.generatingTexture) return;\n\n        // We need to preserve the current texture and don't release it until the new texture is generated.\n        // It's necessary to ensure that the texture won't be captured by another field and overwritten with their\n        // content, while our texture is still in progress.\n        const oldTexturePromise = batchableHTMLText.texturePromise;\n\n        batchableHTMLText.texturePromise = null;\n\n        batchableHTMLText.generatingTexture = true;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n        let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n\n        if (oldTexturePromise)\n        {\n            // Release old texture after new one is generated.\n            texturePromise = texturePromise.finally(() =>\n            {\n                this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);\n                this._renderer.htmlText.returnTexturePromise(oldTexturePromise);\n            });\n        }\n\n        batchableHTMLText.texturePromise = texturePromise;\n        batchableHTMLText.currentKey = htmlText.styleKey;\n\n        batchableHTMLText.texture = await texturePromise;\n\n        // need a rerender...\n        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            // need a rebuild of the render group\n            renderGroup.structureDidChange = true;\n        }\n\n        batchableHTMLText.generatingTexture = false;\n\n        updateTextBounds(batchableHTMLText, htmlText);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const batchableHTMLText = new BatchableHTMLText(this._renderer);\n\n        batchableHTMLText.renderable = htmlText;\n        batchableHTMLText.transform = htmlText.groupTransform;\n        batchableHTMLText.texture = Texture.EMPTY;\n        batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableHTMLText.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n\n        return batchableHTMLText;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n\n"],"names":["updateTextBounds","BatchableHTMLText","Texture","ExtensionType"],"mappings":";;;;;;;;AAcO,MAAM,YACb,CAAA;AAAA,EAaI,YAAY,QACZ,EAAA;AACI,IAAA,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;AAAA,GACrB;AAAA,EAEO,mBAAmB,QAC1B,EAAA;AACI,IAAM,MAAA,OAAA,GAAU,IAAK,CAAA,WAAA,CAAY,QAAQ,CAAA,CAAA;AAEzC,IAAA,MAAM,SAAS,QAAS,CAAA,QAAA,CAAA;AAExB,IAAI,IAAA,OAAA,CAAQ,eAAe,MAC3B,EAAA;AACI,MAAO,OAAA,IAAA,CAAA;AAAA,KACX;AAEA,IAAO,OAAA,KAAA,CAAA;AAAA,GACX;AAAA,EAEO,aAAA,CAAc,UAAoB,cACzC,EAAA;AACI,IAAM,MAAA,iBAAA,GAAoB,IAAK,CAAA,WAAA,CAAY,QAAQ,CAAA,CAAA;AAEnD,IAAA,IAAI,SAAS,cACb,EAAA;AACI,MAAA,MAAM,aAAa,QAAS,CAAA,eAAA,GAAkB,IAAK,CAAA,SAAA,CAAU,aAAa,QAAS,CAAA,UAAA,CAAA;AAEnF,MAAA,IAAI,kBAAkB,UAAe,KAAA,QAAA,CAAS,QAAY,IAAA,QAAA,CAAS,eAAe,UAClF,EAAA;AAEI,QAAA,IAAA,CAAK,cAAe,CAAA,QAAQ,CAAE,CAAA,KAAA,CAAM,CAAC,CACrC,KAAA;AACI,UAAA,OAAA,CAAQ,MAAM,CAAC,CAAA,CAAA;AAAA,SAClB,CAAA,CAAA;AAAA,OACL;AAEA,MAAA,QAAA,CAAS,cAAiB,GAAA,KAAA,CAAA;AAE1B,MAAAA,iCAAA,CAAiB,mBAAmB,QAAQ,CAAA,CAAA;AAAA,KAChD;AAEA,IAAA,IAAA,CAAK,SAAU,CAAA,WAAA,CAAY,KAAM,CAAA,UAAA,CAAW,mBAAmB,cAAc,CAAA,CAAA;AAAA,GACjF;AAAA,EAEO,iBAAiB,QACxB,EAAA;AACI,IAAM,MAAA,iBAAA,GAAoB,IAAK,CAAA,WAAA,CAAY,QAAQ,CAAA,CAAA;AAEnD,IAAkB,iBAAA,CAAA,QAAA,CAAS,cAAc,iBAAiB,CAAA,CAAA;AAAA,GAC9D;AAAA,EAEA,MAAc,eAAe,QAC7B,EAAA;AACI,IAAA,QAAA,CAAS,cAAiB,GAAA,KAAA,CAAA;AAC1B,IAAM,MAAA,iBAAA,GAAoB,IAAK,CAAA,WAAA,CAAY,QAAQ,CAAA,CAAA;AAEnD,IAAA,IAAI,iBAAkB,CAAA,iBAAA;AAAmB,MAAA,OAAA;AAKzC,IAAA,MAAM,oBAAoB,iBAAkB,CAAA,cAAA,CAAA;AAE5C,IAAA,iBAAA,CAAkB,cAAiB,GAAA,IAAA,CAAA;AAEnC,IAAA,iBAAA,CAAkB,iBAAoB,GAAA,IAAA,CAAA;AAEtC,IAAA,QAAA,CAAS,cAAc,QAAS,CAAA,eAAA,GAAkB,IAAK,CAAA,SAAA,CAAU,aAAa,QAAS,CAAA,UAAA,CAAA;AAEvF,IAAA,IAAI,cAAiB,GAAA,IAAA,CAAK,SAAU,CAAA,QAAA,CAAS,kBAAkB,QAAQ,CAAA,CAAA;AAEvE,IAAA,IAAI,iBACJ,EAAA;AAEI,MAAiB,cAAA,GAAA,cAAA,CAAe,QAAQ,MACxC;AACI,QAAA,IAAA,CAAK,SAAU,CAAA,QAAA,CAAS,sBAAuB,CAAA,iBAAA,CAAkB,UAAU,CAAA,CAAA;AAC3E,QAAK,IAAA,CAAA,SAAA,CAAU,QAAS,CAAA,oBAAA,CAAqB,iBAAiB,CAAA,CAAA;AAAA,OACjE,CAAA,CAAA;AAAA,KACL;AAEA,IAAA,iBAAA,CAAkB,cAAiB,GAAA,cAAA,CAAA;AACnC,IAAA,iBAAA,CAAkB,aAAa,QAAS,CAAA,QAAA,CAAA;AAExC,IAAA,iBAAA,CAAkB,UAAU,MAAM,cAAA,CAAA;AAGlC,IAAM,MAAA,WAAA,GAAc,QAAS,CAAA,WAAA,IAAe,QAAS,CAAA,iBAAA,CAAA;AAErD,IAAA,IAAI,WACJ,EAAA;AAEI,MAAA,WAAA,CAAY,kBAAqB,GAAA,IAAA,CAAA;AAAA,KACrC;AAEA,IAAA,iBAAA,CAAkB,iBAAoB,GAAA,KAAA,CAAA;AAEtC,IAAAA,iCAAA,CAAiB,mBAAmB,QAAQ,CAAA,CAAA;AAAA,GAChD;AAAA,EAEQ,YAAY,QACpB,EAAA;AACI,IAAO,OAAA,QAAA,CAAS,SAAS,IAAK,CAAA,SAAA,CAAU,GAAG,CAAK,IAAA,IAAA,CAAK,YAAY,QAAQ,CAAA,CAAA;AAAA,GAC7E;AAAA,EAEO,YAAY,QACnB,EAAA;AACI,IAAA,MAAM,iBAAoB,GAAA,IAAIC,mCAAkB,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAE9D,IAAA,iBAAA,CAAkB,UAAa,GAAA,QAAA,CAAA;AAC/B,IAAA,iBAAA,CAAkB,YAAY,QAAS,CAAA,cAAA,CAAA;AACvC,IAAA,iBAAA,CAAkB,UAAUC,eAAQ,CAAA,KAAA,CAAA;AACpC,IAAkB,iBAAA,CAAA,MAAA,GAAS,EAAE,IAAM,EAAA,CAAA,EAAG,MAAM,CAAG,EAAA,IAAA,EAAM,CAAG,EAAA,IAAA,EAAM,CAAE,EAAA,CAAA;AAChE,IAAA,iBAAA,CAAkB,WAAe,GAAA,IAAA,CAAK,SAAU,CAAA,YAAA,GAAe,QAAS,CAAA,YAAA,CAAA;AAExE,IAAA,QAAA,CAAS,cAAc,QAAS,CAAA,eAAA,GAAkB,IAAK,CAAA,SAAA,CAAU,aAAa,QAAS,CAAA,UAAA,CAAA;AACvF,IAAA,QAAA,CAAS,QAAS,CAAA,IAAA,CAAK,SAAU,CAAA,GAAG,CAAI,GAAA,iBAAA,CAAA;AAExC,IAAO,OAAA,iBAAA,CAAA;AAAA,GACX;AAAA,EAEO,OACP,GAAA;AACI,IAAA,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;AAAA,GACrB;AACJ,CAAA;AAAA;AA3Ia,YAAA,CAGK,SAAY,GAAA;AAAA,EACtB,IAAM,EAAA;AAAA,IACFC,wBAAc,CAAA,UAAA;AAAA,IACdA,wBAAc,CAAA,WAAA;AAAA,IACdA,wBAAc,CAAA,WAAA;AAAA,GAClB;AAAA,EACA,IAAM,EAAA,UAAA;AACV,CAAA;;;;"}