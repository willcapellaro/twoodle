{"version":3,"file":"bitmapTextSplit.mjs","sources":["../../../../src/scene/text-bitmap/utils/bitmapTextSplit.ts"],"sourcesContent":["import { Container } from '../../container/Container';\nimport { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics';\nimport { type TextStyle } from '../../text/TextStyle';\nimport { type SplitOptions } from '../../text-split/SplitText';\nimport { type TextSplitOutput } from '../../text-split/types';\nimport { BitmapFontManager } from '../BitmapFontManager';\nimport { BitmapText } from '../BitmapText';\nimport { getBitmapTextLayout } from './getBitmapTextLayout';\n\n/**\n * Splits a Text object into segments based on the text's layout and style,\n * and adds these segments as individual Text objects to a specified container.\n *\n * This function handles word wrapping, alignment, and letter spacing,\n * ensuring that each segment is rendered correctly according to the original text's style.\n * @param options - Configuration options for the text split operation.\n * @returns An array of Text objects representing the split segments.\n * @internal\n */\nexport function bitmapTextSplit(\n    options: Pick<SplitOptions, 'text' | 'style'> & { chars: BitmapText[] },\n): TextSplitOutput<BitmapText>\n{\n    const { text, style, chars: existingChars } = options;\n    const textStyle = style as TextStyle;\n    const font = BitmapFontManager.getFont(text, textStyle);\n\n    const segments = CanvasTextMetrics.graphemeSegmenter(text);\n    const layout = getBitmapTextLayout(segments, textStyle, font, true);\n    const scale = layout.scale;\n    const chars: BitmapText[] = [];\n    const words: Container[] = [];\n    const lines: Container[] = [];\n    const lineHeight = style.lineHeight ? style.lineHeight : font.lineHeight * scale;\n\n    let yOffset = 0;\n\n    for (const line of layout.lines)\n    {\n        // if the line is empty, skip it\n        if (line.chars.length === 0) continue;\n\n        const lineContainer = new Container({ label: 'line' });\n\n        lineContainer.y = yOffset;\n        lines.push(lineContainer);\n\n        let currentWordContainer = new Container({ label: 'word' });\n        let currentWordStartIndex = 0;\n\n        for (let i = 0; i < line.chars.length; i++)\n        {\n            const char = line.chars[i];\n\n            if (!char) continue;\n\n            const charData = font.chars[char];\n\n            if (!charData) continue;\n\n            const isSpace = char === ' ';\n            const isLastChar = i === line.chars.length - 1;\n\n            let charInstance: BitmapText;\n\n            if (existingChars.length > 0)\n            {\n                charInstance = existingChars.shift();\n                charInstance.text = char;\n                charInstance.style = textStyle;\n                charInstance.label = `char-${char}`;\n                charInstance.x = (line.charPositions[i]! * scale) - (line.charPositions[currentWordStartIndex]! * scale);\n            }\n            else\n            {\n                // Create a new BitmapText instance if no existing one is available\n                charInstance = new BitmapText({\n                    text: char,\n                    style: textStyle,\n                    label: `char-${char}`,\n                    x: (line.charPositions[i]! * scale) - (line.charPositions[currentWordStartIndex]! * scale),\n                });\n            }\n\n            if (!isSpace)\n            {\n                chars.push(charInstance);\n                // Add to word container\n                currentWordContainer.addChild(charInstance);\n            }\n\n            // Handle word breaks\n            if (isSpace || isLastChar)\n            {\n                if (currentWordContainer.children.length > 0)\n                {\n                    currentWordContainer.x = line.charPositions[currentWordStartIndex]! * scale;\n                    words.push(currentWordContainer);\n                    lineContainer.addChild(currentWordContainer);\n\n                    // Start new word container\n                    currentWordContainer = new Container({ label: 'word' });\n                    currentWordStartIndex = i + 1;\n                }\n            }\n        }\n\n        yOffset += lineHeight;\n    }\n\n    return { chars, lines, words };\n}\n"],"names":[],"mappings":"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"}