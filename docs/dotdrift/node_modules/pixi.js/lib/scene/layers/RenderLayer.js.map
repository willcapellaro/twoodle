{"version":3,"file":"RenderLayer.js","sources":["../../../src/scene/layers/RenderLayer.ts"],"sourcesContent":["import { type InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type Renderer } from '../../rendering/renderers/types';\nimport { warn } from '../../utils/logging/warn';\nimport { type Bounds } from '../container/bounds/Bounds';\nimport { Container } from '../container/Container';\n\n// TODO make it clear render layer cannot have 'filters'\n\n/**\n * Options for configuring a RenderLayer. A RenderLayer allows control over rendering order\n * independent of the scene graph hierarchy.\n * @example\n * ```ts\n * // Basic layer with automatic sorting\n * const layer = new RenderLayer({\n *     sortableChildren: true\n * });\n *\n * // Layer with custom sort function\n * const customLayer = new RenderLayer({\n *     sortableChildren: true,\n *     sortFunction: (a, b) => {\n *         // Sort by y position\n *         return a.position.y - b.position.y;\n *     }\n * });\n *\n * // Add objects to layer while maintaining scene graph parent\n * const sprite = new Sprite(texture);\n * container.addChild(sprite);      // Add to scene graph\n * layer.attach(sprite);            // Add to render layer\n *\n * // Manual sorting when needed\n * const manualLayer = new RenderLayer({\n *     sortableChildren: false\n * });\n * manualLayer.attach(sprite1, sprite2);\n * manualLayer.sortRenderLayerChildren(); // Sort manually\n * ```\n * @category scene\n * @standard\n */\nexport interface RenderLayerOptions\n{\n    /**\n     * If true, the layer's children will be sorted by zIndex before rendering.\n     * If false, you can manually sort the children using sortRenderLayerChildren when needed.\n     * @default false\n     * @example\n     * ```ts\n     * const layer = new RenderLayer({\n     *     sortableChildren: true // Automatically sorts children by zIndex\n     * });\n     * ```\n     * @see {@link RenderLayer#sortRenderLayerChildren} For manual sorting\n     * @see {@link RenderLayer#sortFunction} For customizing the sort logic\n     * @see {@link Container#zIndex} For the default sort property\n     */\n    sortableChildren?: boolean;\n\n    /**\n     * Custom sort function to sort layer children. Default sorts by zIndex.\n     * @param a - First container to compare\n     * @param b - Second container to compare\n     * @returns Negative if a should render before b, positive if b should render before a\n     * @example\n     * ```ts\n     * const layer = new RenderLayer({\n     *     sortFunction: (a, b) => {\n     *         // Sort by y position\n     *         return a.position.y - b.position.y;\n     *     }\n     * });\n     * ```\n     * @see {@link RenderLayer#sortableChildren} For enabling automatic sorting\n     * @see {@link RenderLayer#sortRenderLayerChildren} For manual sorting\n     * @see {@link Container#zIndex} For the default sort property\n     * @default (a, b) => a.zIndex - b.zIndex\n     */\n    sortFunction?: (a: Container, b: Container) => number;\n}\n\n/**\n * The RenderLayer API provides a way to control the rendering order of objects independently\n * of their logical parent-child relationships in the scene graph.\n * This allows developers to decouple how objects are transformed\n * (via their logical parent) from how they are rendered on the screen.\n *\n * ### Key Concepts\n *\n * #### RenderLayers Control Rendering Order:\n * - RenderLayers define where in the render stack objects are drawn,\n * but they do not affect an object's transformations (e.g., position, scale, rotation) or logical hierarchy.\n * - RenderLayers can be added anywhere in the scene graph.\n *\n * #### Logical Parenting Remains Unchanged:\n * - Objects still have a logical parent for transformations via addChild.\n * - Assigning an object to a layer does not reparent it.\n *\n * #### Explicit Control:\n * - Developers assign objects to layers using renderLayer.add and remove them using renderLayer.remove.\n * ---\n * ### API Details\n *\n * #### 1. Creating a RenderLayer\n * A RenderLayer is a lightweight object responsible for controlling render order.\n * It has no children or transformations of its own\n * but can be inserted anywhere in the scene graph to define its render position.\n * ```js\n * const layer = new RenderLayer();\n * app.stage.addChild(layer); // Insert the layer into the scene graph\n * ```\n *\n * #### 2. Adding Objects to a Layer\n * Use renderLayer.add to assign an object to a layer.\n * This overrides the object's default render order defined by its logical parent.\n * ```js\n * const rect = new Graphics();\n * container.addChild(rect);    // Add to logical parent\n * layer.attach(rect);      // Control render order via the layer\n * ```\n *\n * #### 3. Removing Objects from a Layer\n * To stop an object from being rendered in the layer, use remove.\n * ```js\n * layer.remove(rect); // Stop rendering rect via the layer\n * ```\n * When an object is removed from its logical parent (removeChild), it is automatically removed from the layer.\n *\n * #### 4. Re-Adding Objects to Layers\n * If an object is re-added to a logical parent, it does not automatically reassign itself to the layer.\n * Developers must explicitly reassign it.\n * ```js\n * container.addChild(rect);    // Logical parent\n * layer.attach(rect);      // Explicitly reassign to the layer\n * ```\n *\n * #### 5. Layer Position in Scene Graph\n * A layer's position in the scene graph determines its render priority relative to other layers and objects.\n * Layers can be inserted anywhere in the scene graph.\n * ```js\n * const backgroundLayer = new RenderLayer();\n * const uiLayer = new RenderLayer();\n *\n * app.stage.addChild(backgroundLayer);\n * app.stage.addChild(world);\n * app.stage.addChild(uiLayer);\n * ```\n * This is a new API and therefore considered experimental at this stage.\n * While the core is pretty robust, there are still a few tricky issues we need to tackle.\n * However, even with the known issues below, we believe this API is incredibly useful!\n *\n * Known issues:\n *  - Interaction may not work as expected since hit testing does not account for the visual render order created by layers.\n *    For example, if an object is visually moved to the front via a layer, hit testing will still use its original position.\n *  - RenderLayers and their children must all belong to the same renderGroup to work correctly\n * @category scene\n * @class\n * @extends null\n * @standard\n */\nexport class RenderLayer extends Container\n{\n    /**\n     * Default options for RenderLayer instances. These options control the sorting behavior\n     * of objects within the render layer.\n     * @example\n     * ```ts\n     * // Create a custom render layer with modified default options\n     * RenderLayer.defaultOptions = {\n     *     sortableChildren: true,\n     *     sortFunction: (a, b) => a.y - b.y // Sort by vertical position\n     * };\n     *\n     * // All new render layers will use these defaults\n     * const layer1 = new RenderLayer();\n     * // layer1 will have sortableChildren = true\n     * ```\n     * @property {boolean} sortableChildren -\n     * @property {Function} sortFunction -\n     * @see {@link RenderLayer} For the main render layer class\n     * @see {@link Container#zIndex} For the default sort property\n     * @see {@link RenderLayer#sortRenderLayerChildren} For manual sorting\n     */\n    public static defaultOptions: RenderLayerOptions = {\n        /** If true, layer children will be automatically sorted each render. Default is false. */\n        sortableChildren: false,\n        /**\n         * Function used to sort layer children.\n         * Default sorts by zIndex. Accepts two Container objects and returns\n         * a number indicating their relative order.\n         * @param a - First container to compare\n         * @param b - Second container to compare\n         * @returns Negative if a should render before b, positive if b should render before a\n         */\n        sortFunction: (a, b) => a.zIndex - b.zIndex,\n    };\n\n    /** Function used to sort layer children if sortableChildren is true */\n    public sortFunction: (a: Container, b: Container) => number;\n\n    /**\n     * The list of objects that this layer is responsible for rendering. Objects in this list maintain\n     * their original parent in the scene graph but are rendered as part of this layer.\n     * @example\n     * ```ts\n     * const layer = new RenderLayer();\n     * const sprite = new Sprite(texture);\n     *\n     * // Add sprite to scene graph for transforms\n     * container.addChild(sprite);\n     *\n     * // Add to layer for render order control\n     * layer.attach(sprite);\n     * console.log(layer.renderLayerChildren.length); // 1\n     *\n     * // Access objects in the layer\n     * layer.renderLayerChildren.forEach(child => {\n     *     console.log('Layer child:', child);\n     * });\n     *\n     * // Check if object is in layer\n     * const isInLayer = layer.renderLayerChildren.includes(sprite);\n     *\n     * // Clear all objects from layer\n     * layer.detachAll();\n     * console.log(layer.renderLayerChildren.length); // 0\n     * ```\n     * @readonly\n     * @see {@link RenderLayer#attach} For adding objects to the layer\n     * @see {@link RenderLayer#detach} For removing objects from the layer\n     * @see {@link RenderLayer#detachAll} For removing all objects from the layer\n     */\n    public renderLayerChildren: Container[] = [];\n\n    /** @internal */\n    public parent: Container | null;\n    /** @internal */\n    public didChange: boolean;\n    /** @internal */\n    public _updateFlags: number;\n    /** @internal */\n    public parentRenderLayer: null;\n    /** @internal */\n    public destroyed: boolean;\n    /** @internal */\n    public layerParentId: string;\n    /** @internal */\n    public sortableChildren;\n\n    /**\n     * Creates a new RenderLayer instance\n     * @param options - Configuration options for the RenderLayer\n     * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render\n     * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex\n     */\n    constructor(options: RenderLayerOptions = {})\n    {\n        options = { ...RenderLayer.defaultOptions, ...options };\n\n        super();\n\n        this.sortableChildren = options.sortableChildren;\n        this.sortFunction = options.sortFunction;\n    }\n\n    /**\n     * Adds one or more Containers to this render layer. The Containers will be rendered as part of this layer\n     * while maintaining their original parent in the scene graph.\n     *\n     * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.\n     * @example\n     * ```ts\n     * const layer = new RenderLayer();\n     * const container = new Container();\n     * const sprite1 = new Sprite(texture1);\n     * const sprite2 = new Sprite(texture2);\n     *\n     * // Add sprites to scene graph for transforms\n     * container.addChild(sprite1, sprite2);\n     *\n     * // Add sprites to layer for render order control\n     * layer.attach(sprite1, sprite2);\n     *\n     * // Add single sprite with type checking\n     * const typedSprite = layer.attach<Sprite>(new Sprite(texture3));\n     * typedSprite.tint = 'red';\n     *\n     * // Automatically removes from previous layer if needed\n     * const otherLayer = new RenderLayer();\n     * otherLayer.attach(sprite1); // Removes from previous layer\n     * ```\n     * @param children - The Container(s) to add to this layer. Can be any Container or array of Containers.\n     * @returns The first child that was added, for method chaining\n     * @see {@link RenderLayer#detach} For removing objects from the layer\n     * @see {@link RenderLayer#detachAll} For removing all objects from the layer\n     * @see {@link Container#addChild} For adding to scene graph hierarchy\n     */\n    public attach<U extends Container[]>(...children: U): U[0]\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.parentRenderLayer)\n            {\n                if (child.parentRenderLayer === this) continue;\n\n                child.parentRenderLayer.detach(child);\n            }\n\n            this.renderLayerChildren.push(child);\n\n            child.parentRenderLayer = this;\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.structureDidChange = true;\n            }\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Removes one or more Containers from this render layer. The Containers will maintain their\n     * original parent in the scene graph but will no longer be rendered as part of this layer.\n     * @example\n     * ```ts\n     * const layer = new RenderLayer();\n     * const container = new Container();\n     * const sprite1 = new Sprite(texture1);\n     * const sprite2 = new Sprite(texture2);\n     *\n     * // Add sprites to scene graph and layer\n     * container.addChild(sprite1, sprite2);\n     * layer.attach(sprite1, sprite2);\n     *\n     * // Remove single sprite from layer\n     * layer.detach(sprite1);\n     * // sprite1 is still child of container but not rendered in layer\n     *\n     * // Remove multiple sprites at once\n     * const otherLayer = new RenderLayer();\n     * otherLayer.attach(sprite3, sprite4);\n     * otherLayer.detach(sprite3, sprite4);\n     *\n     * // Type-safe detachment\n     * const typedSprite = layer.detach<Sprite>(spriteInLayer);\n     * typedSprite.texture = newTexture; // TypeScript knows this is a Sprite\n     * ```\n     * @param children - The Container(s) to remove from this layer\n     * @returns The first child that was removed, for method chaining\n     * @see {@link RenderLayer#attach} For adding objects to the layer\n     * @see {@link RenderLayer#detachAll} For removing all objects from the layer\n     * @see {@link Container#removeChild} For removing from scene graph hierarchy\n     */\n    public detach<U extends Container[]>(...children: U): U[0]\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            const index = this.renderLayerChildren.indexOf(child);\n\n            if (index !== -1)\n            {\n                this.renderLayerChildren.splice(index, 1);\n            }\n\n            child.parentRenderLayer = null;\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.structureDidChange = true;\n            }\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Removes all objects from this render layer. Objects will maintain their\n     * original parent in the scene graph but will no longer be rendered as part of this layer.\n     * @example\n     * ```ts\n     * const layer = new RenderLayer();\n     * const container = new Container();\n     *\n     * // Add multiple sprites to scene graph and layer\n     * const sprites = [\n     *     new Sprite(texture1),\n     *     new Sprite(texture2),\n     *     new Sprite(texture3)\n     * ];\n     *\n     * container.addChild(...sprites);  // Add to scene graph\n     * layer.attach(...sprites);       // Add to render layer\n     *\n     * // Later, remove all sprites from layer at once\n     * layer.detachAll();\n     * console.log(layer.renderLayerChildren.length); // 0\n     * console.log(container.children.length);        // 3 (still in scene graph)\n     * ```\n     * @returns The RenderLayer instance for method chaining\n     * @see {@link RenderLayer#attach} For adding objects to the layer\n     * @see {@link RenderLayer#detach} For removing individual objects\n     * @see {@link Container#removeChildren} For removing from scene graph\n     */\n    public detachAll()\n    {\n        const layerChildren = this.renderLayerChildren;\n\n        for (let i = 0; i < layerChildren.length; i++)\n        {\n            layerChildren[i].parentRenderLayer = null;\n        }\n\n        this.renderLayerChildren.length = 0;\n    }\n\n    /**\n     * Collects renderables for this layer and its children.\n     * This method is called by the renderer to gather all objects that should be rendered in this layer.\n     * @param instructionSet - The set of instructions to collect renderables into.\n     * @param renderer - The renderer that is collecting renderables.\n     * @param _currentLayer - The current render layer being processed.\n     * @internal\n     */\n    public override collectRenderables(instructionSet: InstructionSet, renderer: Renderer, _currentLayer: RenderLayer): void\n    {\n        const layerChildren = this.renderLayerChildren;\n        const length = layerChildren.length;\n\n        if (this.sortableChildren)\n        {\n            this.sortRenderLayerChildren();\n        }\n\n        for (let i = 0; i < length; i++)\n        {\n            if (!layerChildren[i].parent)\n            {\n                // eslint-disable-next-line max-len\n                warn('Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)',\n                    layerChildren[i]);\n            }\n\n            layerChildren[i].collectRenderables(instructionSet, renderer, this);\n        }\n    }\n\n    /**\n     * Sort the layer's children using the defined sort function. This method allows manual sorting\n     * of layer children and is automatically called during rendering if sortableChildren is true.\n     * @example\n     * ```ts\n     * const layer = new RenderLayer();\n     *\n     * // Add multiple sprites at different depths\n     * const sprite1 = new Sprite(texture);\n     * const sprite2 = new Sprite(texture);\n     * const sprite3 = new Sprite(texture);\n     *\n     * sprite1.zIndex = 3;\n     * sprite2.zIndex = 1;\n     * sprite3.zIndex = 2;\n     *\n     * layer.attach(sprite1, sprite2, sprite3);\n     *\n     * // Manual sorting with default zIndex sort\n     * layer.sortRenderLayerChildren();\n     * // Order is now: sprite2 (1), sprite3 (2), sprite1 (3)\n     *\n     * // Custom sort by y position\n     * layer.sortFunction = (a, b) => a.y - b.y;\n     * layer.sortRenderLayerChildren();\n     *\n     * // Automatic sorting\n     * layer.sortableChildren = true; // Will sort each render\n     * ```\n     * @returns The RenderLayer instance for method chaining\n     * @see {@link RenderLayer#sortableChildren} For enabling automatic sorting\n     * @see {@link RenderLayer#sortFunction} For customizing the sort logic\n     */\n    public sortRenderLayerChildren()\n    {\n        this.renderLayerChildren.sort(this.sortFunction);\n    }\n\n    /**\n     * Recursively calculates the global bounds of this RenderLayer and its children.\n     * @param factorRenderLayers\n     * @param bounds\n     * @param _currentLayer\n     * @internal\n     */\n    public override _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        _currentLayer: RenderLayer,\n    ): void\n    {\n        if (!factorRenderLayers) return;\n\n        const children = this.renderLayerChildren;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            children[i]._getGlobalBoundsRecursive(true, bounds, this);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     * @internal\n     */\n    public getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds\n    {\n        return super.getFastGlobalBounds(factorRenderLayers, bounds);\n    }\n    /**\n     * This method is not available in RenderLayer.\n     *\n     * Calling this method will throw an error. Please use `RenderLayer.attach()` instead.\n     * @param {...any} _children\n     * @throws {Error} Always throws an error as this method is not available.\n     * @ignore\n     */\n    public override addChild<U extends Container[]>(..._children: U): never\n    {\n        throw new Error(\n            'RenderLayer.addChild() is not available. Please use RenderLayer.attach()',\n        );\n    }\n    /**\n     * This method is not available in RenderLayer.\n     * Calling this method will throw an error. Please use `RenderLayer.detach()` instead.\n     * @param {...any} _children\n     * @throws {Error} Always throws an error as this method is not available.\n     * @ignore\n     */\n    public override removeChild<U extends Container[]>(..._children: U): never\n    {\n        throw new Error(\n            'RenderLayer.removeChild() is not available. Please use RenderLayer.detach()',\n        );\n    }\n    /**\n     * This method is not available in RenderLayer.\n     *\n     * Calling this method will throw an error. Please use `RenderLayer.detach()` instead.\n     * @param {number} [_beginIndex]\n     * @param {number} [_endIndex]\n     * @throws {Error} Always throws an error as this method is not available.\n     * @ignore\n     */\n    public override removeChildren(_beginIndex?: number, _endIndex?: number): never\n    {\n        throw new Error(\n            'RenderLayer.removeChildren() is not available. Please use RenderLayer.detach()',\n        );\n    }\n    /**\n     * This method is not available in RenderLayer.\n     *\n     * Calling this method will throw an error.\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     * @ignore\n     */\n    public override removeChildAt(_index: number): never\n    {\n        throw new Error(\n            'RenderLayer.removeChildAt() is not available',\n        );\n    }\n    /**\n     * This method is not available in RenderLayer.\n     *\n     * Calling this method will throw an error.\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     * @ignore\n     */\n    public override getChildAt(_index: number): never\n    {\n        throw new Error(\n            'RenderLayer.getChildAt() is not available',\n        );\n    }\n    /**\n     * This method is not available in RenderLayer.\n     *\n     * Calling this method will throw an error.\n     * @param {Container} _child\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     * @ignore\n     */\n    public override setChildIndex(_child: Container, _index: number): never\n    {\n        throw new Error(\n            'RenderLayer.setChildIndex() is not available',\n        );\n    }\n    /**\n     * This method is not available in RenderLayer.\n     *\n     * Calling this method will throw an error.\n     * @param {Container} _child\n     * @throws {Error} Always throws an error as this method is not available.\n     * @ignore\n     */\n    public override getChildIndex(_child: Container): never\n    {\n        throw new Error(\n            'RenderLayer.getChildIndex() is not available',\n        );\n    }\n    /**\n     * This method is not available in RenderLayer.\n     *\n     * Calling this method will throw an error.\n     * @param {Container} _child\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     * @ignore\n     */\n    public override addChildAt<U extends Container>(_child: U, _index: number): never\n    {\n        throw new Error(\n            'RenderLayer.addChildAt() is not available',\n        );\n    }\n    /**\n     * This method is not available in RenderLayer.\n     *\n     * Calling this method will throw an error.\n     * @param {Container} _child\n     * @param {Container} _child2\n     * @ignore\n     */\n    public override swapChildren<U extends Container>(_child: U, _child2: U): never\n    {\n        throw new Error(\n            'RenderLayer.swapChildren() is not available',\n        );\n    }\n\n    /**\n     * This method is not available in RenderLayer.\n     *\n     * Calling this method will throw an error.\n     * @param _child - The child to reparent\n     * @throws {Error} Always throws an error as this method is not available.\n     * @ignore\n     */\n    public override reparentChild(..._child: Container[]): never\n    {\n        throw new Error('RenderLayer.reparentChild() is not available with the render layer');\n    }\n\n    /**\n     * This method is not available in RenderLayer.\n     *\n     * Calling this method will throw an error.\n     * @param _child - The child to reparent\n     * @param _index - The index to reparent the child to\n     * @throws {Error} Always throws an error as this method is not available.\n     * @ignore\n     */\n    public override reparentChildAt(_child: Container, _index: number): never\n    {\n        throw new Error('RenderLayer.reparentChildAt() is not available with the render layer');\n    }\n}\n"],"names":["Container","warn"],"mappings":"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"}