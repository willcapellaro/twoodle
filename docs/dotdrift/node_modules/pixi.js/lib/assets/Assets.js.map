{"version":3,"file":"Assets.js","sources":["../../src/assets/Assets.ts"],"sourcesContent":["/* eslint-disable max-len */\nimport { extensions, ExtensionType } from '../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from '../scene/text-bitmap/asset/loadBitmapFont';\nimport { warn } from '../utils/logging/warn';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray';\nimport { detectAvif } from './detections/parsers/detectAvif';\nimport { detectDefaults } from './detections/parsers/detectDefaults';\nimport { detectMp4 } from './detections/parsers/detectMp4';\nimport { detectOgv } from './detections/parsers/detectOgv';\nimport { detectWebm } from './detections/parsers/detectWebm';\nimport { detectWebp } from './detections/parsers/detectWebp';\nimport { Loader, type LoadOptions } from './loader/Loader';\nimport { loadJson } from './loader/parsers/loadJson';\nimport { loadTxt } from './loader/parsers/loadTxt';\nimport { loadWebFont } from './loader/parsers/loadWebFont';\nimport { loadSvg } from './loader/parsers/textures/loadSVG';\nimport { type LoadTextureConfig, loadTextures } from './loader/parsers/textures/loadTextures';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nimport type { AssetExtension } from './AssetExtension';\nimport type { FormatDetectionParser } from './detections/types';\nimport type { LoadSVGConfig } from './loader/parsers/textures/loadSVG';\nimport type { BundleIdentifierOptions } from './resolver/Resolver';\nimport type { ArrayOr, AssetsBundle, AssetsManifest, ResolvedAsset, UnresolvedAsset } from './types';\n\n/**\n * Callback function for tracking asset loading progress. The function is called repeatedly\n * during the loading process with a progress value between 0.0 and 1.0.\n * @param progress - The loading progress from 0.0 (started) to 1.0 (complete)\n * @returns void\n * @example\n * ```ts\n * // Basic progress logging\n * const onProgress = (progress: number) => {\n *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n * };\n *\n * // Update loading bar\n * const onProgress = (progress: number) => {\n *     loadingBar.width = progress * 100;\n *     loadingText.text = `${Math.round(progress * 100)}%`;\n * };\n *\n * // Load assets with progress tracking\n * await Assets.load(['sprite1.png', 'sprite2.png'], onProgress);\n *\n * // Load bundle with progress tracking\n * await Assets.loadBundle('levelAssets', (progress) => {\n *     // Progress is normalized (0.0 - 1.0)\n *     updateLoadingScreen(progress);\n * });\n * ```\n * > [!IMPORTANT] Do not rely on the progress callback to determine when all assets are loaded.\n * > Use the returned promise from `Assets.load()` or `Assets.loadBundle()` to know when loading is complete.\n * @category assets\n * @standard\n */\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Extensible preferences that can be used, for instance, when configuring loaders.\n * @since 7.2.0\n * @advanced\n * @category assets\n */\nexport interface AssetsPreferences extends LoadTextureConfig, LoadSVGConfig, PixiMixins.AssetsPreferences {}\n\n/**\n * Options for initializing the Assets class. These options configure how assets are loaded,\n * resolved, and managed in your PixiJS application.\n * @category assets\n * @standard\n */\nexport interface AssetInitOptions\n{\n    /**\n     * Base path prepended to all asset URLs. Useful for CDN hosting.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     basePath: 'https://my-cdn.com/assets/'\n     * });\n     *\n     * // Now you can load assets like this:\n     * // Will load from: https://my-cdn.com/assets/images/sprite.png\n     * const texture = await Assets.load('images/sprite.png');\n     * ```\n     */\n    basePath?: string;\n\n    /**\n     * URL parameters to append to all asset URLs.\n     * Useful for cache-busting or version control.\n     * @example\n     * ```ts\n     * // As a string\n     * await Assets.init({\n     *     defaultSearchParams: 'version=1.0.0'\n     * });\n     *\n     * // As an object\n     * await Assets.init({\n     *     defaultSearchParams: {\n     *         version: '1.0.0',\n     *         t: Date.now()\n     *     }\n     * });\n     * ```\n     * @advanced\n     */\n    defaultSearchParams?: string | Record<string, any>;\n\n    /**\n     * A manifest defining all your application's assets.\n     * Can be a URL to a JSON file or a manifest object.\n     * @example\n     * ```ts\n     * // Using a manifest object\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [{\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'hero',\n     *                     src: 'hero.{png,webp}'\n     *                 },\n     *                 {\n     *                     alias: 'map',\n     *                     src: 'map.json'\n     *                 }\n     *             ]\n     *         }]\n     *     }\n     * });\n     *\n     * // Using a URL to manifest\n     * await Assets.init({\n     *     manifest: 'assets/manifest.json'\n     * });\n     *\n     * // loading a bundle from the manifest\n     * await Assets.loadBundle('game-screen');\n     *\n     * // load individual assets from the manifest\n     * const heroTexture = await Assets.load('hero');\n     * ```\n     */\n    manifest?: string | AssetsManifest;\n    /**\n     * Configure texture loading preferences.\n     * Useful for optimizing asset delivery based on device capabilities.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     texturePreference: {\n     *         // Prefer high-res textures on retina displays\n     *         resolution: window.devicePixelRatio,\n     *\n     *         // Prefer modern formats, fallback to traditional\n     *         format: ['avif', 'webp', 'png']\n     *     }\n     * });\n     * ```\n     */\n    texturePreference?: {\n        /** Preferred texture resolution(s). Can be a single number or array of resolutions in order of preference. */\n        resolution?: number | number[];\n\n        /** Preferred texture formats in order of preference. Default: ['avif', 'webp', 'png', 'jpg', 'jpeg'] */\n        format?: ArrayOr<string>;\n    };\n\n    /**\n     * Skip browser format detection for faster initialization.\n     * Only use if you know exactly what formats your target browsers support.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     skipDetections: true,\n     *     texturePreference: {\n     *         format: ['webp', 'png'] // Must explicitly set formats\n     *     }\n     * });\n     * ```\n     * @advanced\n     */\n    skipDetections?: boolean;\n\n    /**\n     * Override how bundle IDs are generated and resolved.\n     *\n     * This allows you to customize how assets are grouped and accessed via bundles and allow for\n     * multiple bundles to share the same asset keys.\n     * @advanced\n     * @example\n     * ```ts\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'bunny1',\n     *             assets: [\n     *                 {\n     *                     alias: ['character', 'character2'],\n     *                     src: 'textures/bunny.png',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'bunny2',\n     *             assets: [\n     *                 {\n     *                     alias: ['character', 'character2'],\n     *                     src: 'textures/bunny-2.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * const bundleIdentifier: BundleIdentifierOptions = {\n     *     connector: ':',\n     * };\n     *\n     * await Assets.init({ manifest, basePath, bundleIdentifier });\n     *\n     * const resources = await Assets.loadBundle('bunny1');\n     * const resources2 = await Assets.loadBundle('bunny2');\n     *\n     * console.log(resources.character === resources2.character); // false\n     * ```\n     */\n    bundleIdentifier?: BundleIdentifierOptions;\n\n    /**\n     * Optional preferences for asset loading behavior.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     preferences: {\n     *         crossOrigin: 'anonymous',\n     *         parseAsGraphicsContext: false\n     *     }\n     * });\n     * ```\n     */\n    preferences?: Partial<AssetsPreferences>;\n\n    /**\n     * Options for defining the loading behavior of assets.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *    loadOptions: {\n     *       onProgress: (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`),\n     *       onError: (error, asset) => console.error(`Error loading ${asset.src}: ${error.message}`),\n     *       strategy: 'retry',\n     *       retryCount: 5,\n     *       retryDelay: 500,\n     *   }\n     * });\n     * ```\n     * @remarks\n     * - `onProgress` callback receives values from 0.0 to 1.0\n     * - `onError` callback is invoked for individual asset load failures\n     * - `strategy` can be 'throw' (default), 'retry', or 'skip'\n     * - `retryCount` sets how many times to retry failed assets (default 3)\n     * - `retryDelay` sets the delay between retries in milliseconds (default 250ms)\n     * @see {@link LoadOptions} For all available load options\n     */\n    loadOptions?: Partial<LoadOptions>;\n}\n\n/** @internal */\nexport class AssetsClass\n{\n    /**\n     * The URL resolver for assets. Maps various asset keys and URLs to their final loadable form.\n     * @advanced\n     */\n    public resolver: Resolver;\n    /**\n     *  The loader responsible for loading all assets. Handles different file types\n     * and transformations.\n     * @advanced\n     */\n    public loader: Loader;\n    /**\n     * The global cache for all loaded assets. Manages storage and retrieval of\n     * processed assets.\n     * @example\n     * ```ts\n     * // Check if an asset is cached\n     * if (Assets.cache.has('myTexture')) {\n     *     const texture = Assets.cache.get('myTexture');\n     * }\n     * ```\n     * @see {@link Cache} For detailed cache documentation\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private readonly _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Initializes the Assets class with configuration options. While not required,\n     * calling this before loading assets is recommended to set up default behaviors.\n     * @param options - Configuration options for the Assets system\n     * @example\n     * ```ts\n     * // Basic initialization (optional as Assets.load will call this automatically)\n     * await Assets.init();\n     *\n     * // With CDN configuration\n     * await Assets.init({\n     *     basePath: 'https://my-cdn.com/assets/',\n     *     defaultSearchParams: { version: '1.0.0' }\n     * });\n     *\n     * // With manifest and preferences\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [{\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'hero',\n     *                     src: 'hero.{png,webp}',\n     *                     data: { scaleMode: SCALE_MODES.NEAREST }\n     *                 },\n     *                 {\n     *                     alias: 'map',\n     *                     src: 'map.json'\n     *                 }\n     *             ]\n     *         }]\n     *     },\n     *     // Optimize for device capabilities\n     *     texturePreference: {\n     *         resolution: window.devicePixelRatio,\n     *         format: ['webp', 'png']\n     *     },\n     *     // Set global preferences\n     *     preferences: {\n     *         crossOrigin: 'anonymous',\n     *     }\n     * });\n     *\n     * // Load assets after initialization\n     * const heroTexture = await Assets.load('hero');\n     * ```\n     * @remarks\n     * - Can be called only once; subsequent calls will be ignored with a warning\n     * - Format detection runs automatically unless `skipDetections` is true\n     * - The manifest can be a URL to a JSON file or an inline object\n     * @see {@link AssetInitOptions} For all available initialization options\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            warn('[Assets]AssetManager already initialized, did you load before calling this Assets.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.defaultSearchParams)\n        {\n            this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        }\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.bundleIdentifier)\n        {\n            this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<AssetsManifest>(manifest);\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        const formats = await this._detectFormats({\n            preferredFormats: options.texturePreference?.format,\n            skipDetections: options.skipDetections,\n            detections: this._detections\n        });\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n\n        if (options.preferences)\n        {\n            this.setPreferences(options.preferences);\n        }\n\n        // set load options on the loader\n        if (options.loadOptions)\n        {\n            this.loader.loadOptions = {\n                ...this.loader.loadOptions,\n                ...options.loadOptions\n            };\n        }\n    }\n\n    /**\n     * Registers assets with the Assets resolver. This method maps keys (aliases) to asset sources,\n     * allowing you to load assets using friendly names instead of direct URLs.\n     * @param assets - The unresolved assets to add to the resolver\n     * @example\n     * ```ts\n     * // Basic usage - single asset\n     * Assets.add({\n     *     alias: 'myTexture',\n     *     src: 'assets/texture.png'\n     * });\n     * const texture = await Assets.load('myTexture');\n     *\n     * // Multiple aliases for the same asset\n     * Assets.add({\n     *     alias: ['hero', 'player'],\n     *     src: 'hero.png'\n     * });\n     * const hero1 = await Assets.load('hero');\n     * const hero2 = await Assets.load('player'); // Same texture\n     *\n     * // Multiple format support\n     * Assets.add({\n     *     alias: 'character',\n     *     src: 'character.{webp,png}' // Will choose best format\n     * });\n     * Assets.add({\n     *     alias: 'character',\n     *     src: ['character.webp', 'character.png'], // Explicitly specify formats\n     * });\n     *\n     * // With texture options\n     * Assets.add({\n     *     alias: 'sprite',\n     *     src: 'sprite.png',\n     *     data: { scaleMode: 'nearest' }\n     * });\n     *\n     * // Multiple assets at once\n     * Assets.add([\n     *     { alias: 'bg', src: 'background.png' },\n     *     { alias: 'music', src: 'music.mp3' },\n     *     { alias: 'spritesheet', src: 'sheet.json', data: { ignoreMultiPack: false } }\n     * ]);\n     * ```\n     * @remarks\n     * - Assets are resolved when loaded, not when added\n     * - Multiple formats use the best available format for the browser\n     * - Adding with same alias overwrites previous definition\n     * - The `data` property is passed to the asset loader\n     * @see {@link Resolver} For details on asset resolution\n     * @see {@link LoaderParser} For asset-specific data options\n     * @advanced\n     */\n    public add(assets: (ArrayOr<UnresolvedAsset>)): void\n    {\n        this.resolver.add(assets);\n    }\n\n    /**\n     * Loads one or more assets and returns a promise that resolves with the loaded content.\n     * Assets are cached, so subsequent loads will return the same instance of the asset without re-fetching.\n     * @param urls - Single URL/alias or array of URLs/aliases to load\n     * @param onProgress - Optional callback for load progress (0.0 to 1.0)\n     * @returns Promise that resolves with loaded asset(s)\n     * @example\n     * ```ts\n     * // Load a single asset\n     * const texture = await Assets.load('images/sprite.png');\n     *\n     * // Load using an alias\n     * const heroTexture = await Assets.load({ alias: 'hero', src: 'images/hero.png' });\n     *\n     * // Load multiple assets\n     * const assets = await Assets.load([\n     *     'images/background.png',\n     *     'images/character.png',\n     *     'fonts/game.fnt'\n     * ]);\n     * console.log(assets['images/background.png']); // Access by URL\n     *\n     * // Load with progress tracking\n     * const textures = await Assets.load(['sprite1.png', 'sprite2.png'],\n     *     (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`)\n     * );\n     *\n     * // Load with format preference\n     * const characterTexture = await Assets.load({\n     *     alias: 'character',\n     *     src: 'character.{webp,png}' // Will choose best format\n     * });\n     *\n     * // Load with custom options\n     * const spriteTexture = await Assets.load({\n     *     alias: 'sprite',\n     *     src: 'sprite.png',\n     *     data: {\n     *         scaleMode: SCALE_MODES.NEAREST,\n     *         mipmap: MIPMAP_MODES.ON\n     *     }\n     * });\n     *\n     * // Load with a specific loader, can be useful if your asset does not have an extension\n     * const image = await Assets.load({\n     *    alias: 'imageWithoutExtension',\n     *    src: 'images/imageWithoutExtension',\n     *    parser: 'texture' // Use the JSON loader\n     * });\n     * ```\n     * @remarks\n     * - Assets are cached automatically to prevent duplicate loading\n     * - URLs are resolved to the best format for the current browser\n     * - Asset types are detected automatically based on file extension\n     * - Progress callback receives values from 0.0 to 1.0\n     * - You can define with loader to use for an asset by specifying the `parser` property, which is useful for assets that do not have a file extension.\n     * @throws {Error} If the asset cannot be loaded or parsed\n     * @see {@link Assets.add} For registering assets with aliases\n     * @see {@link Assets.backgroundLoad} For loading assets in the background\n     * @see {@link Assets.unload} For releasing loaded assets\n     */\n    public async load<T = any>(\n        urls: string | UnresolvedAsset,\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<T>;\n    public async load<T = any>(\n        urls: string[] | UnresolvedAsset[],\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        urls: ArrayOr<string> | ArrayOr<UnresolvedAsset>,\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray: string[] = convertToList<UnresolvedAsset | string>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    const aliases = this.resolver.getAlias(url);\n\n                    if (aliases.some((alias) => !this.resolver.hasKey(alias)))\n                    {\n                        this.add(url);\n                    }\n\n                    return Array.isArray(aliases) ? aliases[0] : aliases;\n                }\n\n                // if it hasn't been added, add it now\n                if (!this.resolver.hasKey(url)) this.add({ alias: url, src: url });\n\n                return url;\n            }) as string[];\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * Registers a bundle of assets that can be loaded as a group. Bundles are useful for organizing\n     * assets into logical groups, such as game levels or UI screens.\n     * @param bundleId - Unique identifier for the bundle\n     * @param assets - Assets to include in the bundle\n     * @example\n     * ```ts\n     * // Add a bundle using array format\n     * Assets.addBundle('animals', [\n     *     { alias: 'bunny', src: 'bunny.png' },\n     *     { alias: 'chicken', src: 'chicken.png' },\n     *     { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     *\n     * // Add a bundle using object format\n     * Assets.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * // Add a bundle with advanced options\n     * Assets.addBundle('ui', [\n     *     {\n     *         alias: 'button',\n     *         src: 'button.{webp,png}',\n     *         data: { scaleMode: 'nearest' }\n     *     },\n     *     {\n     *         alias: ['logo', 'brand'],  // Multiple aliases\n     *         src: 'logo.svg',\n     *         data: { resolution: 2 }\n     *     }\n     * ]);\n     *\n     * // Load the bundle\n     * await Assets.loadBundle('animals');\n     *\n     * // Use the loaded assets\n     * const bunny = Sprite.from('bunny');\n     * const chicken = Sprite.from('chicken');\n     * ```\n     * @remarks\n     * - Bundle IDs must be unique\n     * - Assets in bundles are not loaded until `loadBundle` is called\n     * - Bundles can be background loaded using `backgroundLoadBundle`\n     * - Assets in bundles can be loaded individually using their aliases\n     * @see {@link Assets.loadBundle} For loading bundles\n     * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n     * @see {@link Assets.unloadBundle} For unloading bundles\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Loads a bundle or multiple bundles of assets. Bundles are collections of related assets\n     * that can be loaded together.\n     * @param bundleIds - Single bundle ID or array of bundle IDs to load\n     * @param onProgress - Optional callback for load progress (0.0 to 1.0)\n     * @returns Promise that resolves with the loaded bundle assets\n     * @example\n     * ```ts\n     * // Define bundles in your manifest\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}', // use an array of individual assets\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * // Initialize with manifest\n     * await Assets.init({ manifest });\n     *\n     * // Or add bundles programmatically\n     * Assets.addBundle('load-screen', [...]);\n     * Assets.loadBundle('load-screen');\n     *\n     * // Load a single bundle\n     * await Assets.loadBundle('load-screen');\n     * const bg = Sprite.from('background'); // Uses alias from bundle\n     *\n     * // Load multiple bundles\n     * await Assets.loadBundle([\n     *     'load-screen',\n     *     'game-screen'\n     * ]);\n     *\n     * // Load with progress tracking\n     * await Assets.loadBundle('game-screen', (progress) => {\n     *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n     * });\n     * ```\n     * @remarks\n     * - Bundle assets are cached automatically\n     * - Bundles can be pre-loaded using `backgroundLoadBundle`\n     * - Assets in bundles can be accessed by their aliases\n     * - Progress callback receives values from 0.0 to 1.0\n     * @throws {Error} If the bundle ID doesn't exist in the manifest\n     * @see {@link Assets.addBundle} For adding bundles programmatically\n     * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n     * @see {@link Assets.unloadBundle} For unloading bundles\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async loadBundle(bundleIds: ArrayOr<string>, onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let total = 0;\n        const counts: number[] = [];\n        const _onProgress = () =>\n        {\n            onProgress?.(counts.reduce((a, b) => a + b, 0) / total);\n        };\n        const promises = keys.map((bundleId, i) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n            const values = Object.values(resolveResult);\n            const totalAssetsToLoad = [...new Set(values.flat())] as ResolvedAsset[];\n\n            const progressSize = totalAssetsToLoad.reduce((sum, asset) => sum + (asset.progressSize || 1), 0);\n\n            counts.push(0);\n            total += progressSize;\n\n            return this._mapLoadToResolve(resolveResult, (e) =>\n            {\n                counts[i] = e * progressSize;\n                _onProgress();\n            })\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiates background loading of assets. This allows assets to be loaded passively while other operations\n     * continue, making them instantly available when needed later.\n     *\n     * Background loading is useful for:\n     * - Preloading game levels while in a menu\n     * - Loading non-critical assets during gameplay\n     * - Reducing visible loading screens\n     * @param urls - Single URL/alias or array of URLs/aliases to load in the background\n     * @example\n     * ```ts\n     * // Basic background loading\n     * Assets.backgroundLoad('images/level2-assets.png');\n     *\n     * // Background load multiple assets\n     * Assets.backgroundLoad([\n     *     'images/sprite1.png',\n     *     'images/sprite2.png',\n     *     'images/background.png'\n     * ]);\n     *\n     * // Later, when you need the assets\n     * const textures = await Assets.load([\n     *     'images/sprite1.png',\n     *     'images/sprite2.png'\n     * ]); // Resolves immediately if background loading completed\n     * ```\n     * @remarks\n     * - Background loading happens one asset at a time to avoid blocking the main thread\n     * - Loading can be interrupted safely by calling `Assets.load()`\n     * - Assets are cached as they complete loading\n     * - No progress tracking is available for background loading\n     */\n    public async backgroundLoad(urls: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiates background loading of asset bundles. Similar to backgroundLoad but works with\n     * predefined bundles of assets.\n     *\n     * Perfect for:\n     * - Preloading level bundles during gameplay\n     * - Loading UI assets during splash screens\n     * - Preparing assets for upcoming game states\n     * @param bundleIds - Single bundle ID or array of bundle IDs to load in the background\n     * @example\n     * ```ts\n     * // Define bundles in your manifest\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [\n     *             {\n     *               name: 'home',\n     *               assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'images/home-bg.png',\n     *                 },\n     *                 {\n     *                     alias: 'logo',\n     *                     src: 'images/logo.png',\n     *                 }\n     *              ]\n     *            },\n     *            {\n     *             name: 'level-1',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'images/level1/bg.png',\n     *                 },\n     *                 {\n     *                     alias: 'sprites',\n     *                     src: 'images/level1/sprites.json'\n     *                 }\n     *             ]\n     *         }]\n     *     }\n     * });\n     *\n     * // Load the home screen assets right away\n     * await Assets.loadBundle('home');\n     * showHomeScreen();\n     *\n     * // Start background loading while showing home screen\n     * Assets.backgroundLoadBundle('level-1');\n     *\n     * // When player starts level, load completes faster\n     * await Assets.loadBundle('level-1');\n     * hideHomeScreen();\n     * startLevel();\n     * ```\n     * @remarks\n     * - Bundle assets are loaded one at a time\n     * - Loading can be interrupted safely by calling `Assets.loadBundle()`\n     * - Assets are cached as they complete loading\n     * - Requires bundles to be registered via manifest or `addBundle`\n     * @see {@link Assets.addBundle} For adding bundles programmatically\n     * @see {@link Assets.loadBundle} For immediate bundle loading\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async backgroundLoadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     * @internal\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. Returns undefined if the asset hasn't been loaded yet.\n     * @param keys - The key or keys for the assets to retrieve\n     * @returns The cached asset(s) or undefined if not loaded\n     * @example\n     * ```ts\n     * // Get a single cached asset\n     * const texture = Assets.get('hero');\n     * if (texture) {\n     *     const sprite = new Sprite(texture);\n     * }\n     *\n     * // Get multiple cached assets\n     * const textures = Assets.get([\n     *     'hero',\n     *     'background',\n     *     'enemy'\n     * ]);\n     *\n     * // Safe pattern with loading fallback\n     * let texture = Assets.get('hero');\n     * if (!texture) {\n     *     texture = await Assets.load('hero');\n     * }\n     *\n     * // Working with bundles\n     * await Assets.loadBundle('game-ui');\n     * const uiAssets = Assets.get([\n     *     'button',\n     *     'panel',\n     *     'icons'\n     * ]);\n     * ```\n     * @remarks\n     * - Returns undefined if asset isn't loaded\n     * - No automatic loading - use `Assets.load()` for that\n     * - Cached assets are shared instances\n     * - Faster than `load()` for already cached assets\n     *\n     * > [!TIP]\n     * > When in doubt, use `Assets.load()` instead. It will return cached\n     * > assets instantly if they're already loaded.\n     * @see {@link Assets.load} For loading assets that aren't cached\n     * @see {@link Assets.cache} For direct cache access\n     */\n    public get<T = any>(keys: string): T;\n    public get<T = any>(keys: string[]): Record<string, T>;\n    public get<T = any>(keys: ArrayOr<string>): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param progressOrLoadOptions - the progress callback or load options\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolvedAsset | Record<string, ResolvedAsset>,\n        progressOrLoadOptions?: ProgressCallback | LoadOptions,\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = [...new Set(Object.values(resolveResults))] as ResolvedAsset[];\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load<T>(resolveArray, progressOrLoadOptions);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            keys.forEach((key) =>\n            {\n                out[key] = asset;\n            });\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unloads assets and releases them from memory. This method ensures proper cleanup of\n     * loaded assets when they're no longer needed.\n     * @param urls - Single URL/alias or array of URLs/aliases to unload\n     * @example\n     * ```ts\n     * // Unload a single asset\n     * await Assets.unload('images/sprite.png');\n     *\n     * // Unload using an alias\n     * await Assets.unload('hero'); // Unloads the asset registered with 'hero' alias\n     *\n     * // Unload multiple assets\n     * await Assets.unload([\n     *     'images/background.png',\n     *     'images/character.png',\n     *     'hero'\n     * ]);\n     *\n     * // Unload and handle creation of new instances\n     * await Assets.unload('hero');\n     * const newHero = await Assets.load('hero'); // Will load fresh from source\n     * ```\n     * @remarks\n     * > [!WARNING]\n     * > Make sure assets aren't being used before unloading:\n     * > - Remove sprites using the texture\n     * > - Clear any references to the asset\n     * > - Textures will be destroyed and can't be used after unloading\n     * @throws {Error} If the asset is not found in cache\n     */\n    public async unload(\n        urls: ArrayOr<string> | ResolvedAsset | ResolvedAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | ResolvedAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Unloads all assets in a bundle. Use this to free memory when a bundle's assets\n     * are no longer needed, such as when switching game levels.\n     * @param bundleIds - Single bundle ID or array of bundle IDs to unload\n     * @example\n     * ```ts\n     * // Define and load a bundle\n     * Assets.addBundle('level-1', {\n     *     background: 'level1/bg.png',\n     *     sprites: 'level1/sprites.json',\n     *     music: 'level1/music.mp3'\n     * });\n     *\n     * // Load the bundle\n     * const level1 = await Assets.loadBundle('level-1');\n     *\n     * // Use the assets\n     * const background = Sprite.from(level1.background);\n     *\n     * // When done with the level, unload everything\n     * await Assets.unloadBundle('level-1');\n     * // background sprite is now invalid!\n     *\n     * // Unload multiple bundles\n     * await Assets.unloadBundle([\n     *     'level-1',\n     *     'level-2',\n     *     'ui-elements'\n     * ]);\n     * ```\n     * @remarks\n     * > [!WARNING]\n     * > - All assets in the bundle will be destroyed\n     * > - Bundle needs to be reloaded to use assets again\n     * > - Make sure no sprites or other objects are using the assets\n     * @throws {Error} If the bundle is not found\n     * @see {@link Assets.addBundle} For adding bundles\n     * @see {@link Assets.loadBundle} For loading bundles\n     */\n    public async unloadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolvedAsset | Record<string, ResolvedAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /**\n     * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n     * the users preferred formats order.\n     * @param options - the options to use when detecting formats\n     * @param options.preferredFormats - the preferred formats to use\n     * @param options.skipDetections - if we should skip the detections altogether\n     * @param options.detections - the detections to use\n     * @returns - the detected formats\n     */\n    private async _detectFormats(options: {\n        preferredFormats: string | string[],\n        skipDetections: boolean,\n        detections: FormatDetectionParser[]\n    }): Promise<string[]>\n    {\n        let formats: string[] = [];\n\n        // set preferred formats\n        if (options.preferredFormats)\n        {\n            formats = Array.isArray(options.preferredFormats)\n                ? options.preferredFormats : [options.preferredFormats];\n        }\n\n        // we should add any formats that are supported by the browser\n        for (const detection of options.detections)\n        {\n            if (options.skipDetections || await detection.test())\n            {\n                formats = await detection.add(formats);\n            }\n            else if (!options.skipDetections)\n            {\n                formats = await detection.remove(formats);\n            }\n        }\n\n        // remove any duplicates\n        formats = formats.filter((format, index) => formats.indexOf(format) === index);\n\n        return formats;\n    }\n\n    /**\n     * All the detection parsers currently added to the Assets class.\n     * @advanced\n     */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n\n    /**\n     * Sets global preferences for asset loading behavior. This method configures how assets\n     * are loaded and processed across all parsers.\n     * @param preferences - Asset loading preferences\n     * @example\n     * ```ts\n     * // Basic preferences\n     * Assets.setPreferences({\n     *     crossOrigin: 'anonymous',\n     *     parseAsGraphicsContext: false\n     * });\n     * ```\n     * @remarks\n     * Preferences are applied to all compatible parsers and affect future asset loading.\n     * Common preferences include:\n     * - `crossOrigin`: CORS setting for loaded assets\n     * - `preferWorkers`: Whether to use web workers for loading textures\n     * - `preferCreateImageBitmap`: Use `createImageBitmap` for texture creation. Turning this off will use the `Image` constructor instead.\n     * @see {@link AssetsPreferences} For all available preferences\n     */\n    public setPreferences(preferences: Partial<AssetsPreferences>): void\n    {\n        // Find matching config keys in loaders with preferences\n        // and set the values\n        this.loader.parsers.forEach((parser) =>\n        {\n            if (!parser.config) return;\n\n            (Object.keys(parser.config) as (keyof AssetsPreferences)[])\n                .filter((key) => key in preferences)\n                .forEach((key) =>\n                {\n                    parser.config[key] = preferences[key];\n                });\n        });\n    }\n}\n\n/**\n * The global Assets class is a singleton that manages loading, caching, and unloading of all resources\n * in your PixiJS application.\n *\n * Key responsibilities:\n * - **URL Resolution**: Maps URLs/keys to browser-compatible resources\n * - **Resource Loading**: Handles loading and transformation of assets\n * - **Asset Caching**: Manages a global cache to prevent duplicate loads\n * - **Memory Management**: Provides unloading capabilities to free memory\n *\n * Advanced Features:\n * - **Asset Bundles**: Group and manage related assets together\n * - **Background Loading**: Load assets before they're needed over time\n * - **Format Detection**: Automatically select optimal asset formats\n *\n * Supported Asset Types:\n * | Type                | Extensions                                                       | Loaders                                                               |\n * | ------------------- | ---------------------------------------------------------------- | --------------------------------------------------------------------- |\n * | Textures            | `.png`, `.jpg`, `.gif`, `.webp`, `.avif`, `.svg`                 | {@link loadTextures}, {@link loadSvg}                                 |\n * | Video Textures      | `.mp4`, `.m4v`, `.webm`, `.ogg`, `.ogv`, `.h264`, `.avi`, `.mov` | {@link loadVideoTextures}                                             |\n * | Sprite Sheets       | `.json`                                                          | {@link spritesheetAsset}                                              |\n * | Bitmap Fonts        | `.fnt`, `.xml`, `.txt`                                           | {@link loadBitmapFont}                                                |\n * | Web Fonts           | `.ttf`, `.otf`, `.woff`, `.woff2`                                | {@link loadWebFont}                                                   |\n * | JSON                | `.json`                                                          | {@link loadJson}                                                      |\n * | Text                | `.txt`                                                           | {@link loadTxt}                                                       |\n * | Compressed Textures | `.basis`, `.dds`, `.ktx`, `.ktx2`                                | {@link loadBasis}, {@link loadDDS}, {@link loadKTX}, {@link loadKTX2} |\n * > [!NOTE] Some loaders allow for custom configuration, please refer to the specific loader documentation for details.\n * @example\n * ```typescript\n * import { Assets } from 'pixi.js';\n *\n * // Initialize with options (optional). You can call Assets.load directly without init.\n * await Assets.init({\n *     // Base path for all asset URLs\n *     basePath: 'https://my-cdn.com/assets/',\n *     // Manifest object that defines all assets\n *     manifest: {\n *        bundles: [{ name: 'gameAssets', assets: [] }, ...],\n *     }, *\n *     // Preferred texture settings\n *     texturePreference: {\n *         resolution: window.devicePixelRatio,\n *         format: ['avif', 'webp', 'png']\n *     }\n * });\n *\n * // Basic loading\n * const texture = await Assets.load('images/sprite.png');\n *\n * // Load multiple assets\n * const assets = await Assets.load([\n *     'images/bg.png',\n *     'images/character.png',\n *     'fonts/game.fnt'\n * ]);\n *\n * // Using aliases + multiple formats\n * await Assets.load({ alias: 'hero', src: 'images/hero.{webp,png}' });\n * const sprite = Sprite.from('hero'); // Uses the best available format\n *\n * // background loading\n * Assets.backgroundLoad(['images/level1.json', 'images/level2.json']); // Loads in the background one at a time\n *\n * // Load a bundle of assets from the manifest\n * const levelAssets = await Assets.loadBundle('gameAssets');\n * // Background loading of a bundle. This will load assets in the background one at a time.\n * // Can be interrupted at any time by calling Assets.loadBundle('gameAssets') again.\n * Assets.backgroundLoadBundle('resultsAssets');\n *\n * // Memory management\n * await Assets.unload('hero');\n * await Assets.unloadBundle('levelOne');\n * ```\n * @remarks\n * - Assets are cached automatically and only loaded once\n * - Background loading helps eliminate loading screens\n * - Format detection ensures optimal asset delivery\n * - Bundle management simplifies resource organization\n *\n * > [!IMPORTANT]\n * > When unloading assets, ensure they aren't being used elsewhere\n * > in your application to prevent missing texture references.\n * @see {@link AssetInitOptions} For initialization options\n * @see {@link AssetsPreferences} For advanced preferences\n * @see {@link BackgroundLoader} For background loading capabilities\n * @see {@link AssetsManifest} For manifest-based asset management\n * @see {@link Loader} For the underlying loading system\n * @see {@link Cache} For the caching system\n * @see {@link Resolver} For URL resolution details\n * @category assets\n * @class\n * @standard\n */\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n    cacheTextureArray,\n\n    detectDefaults,\n    detectAvif,\n    detectWebp,\n    detectMp4,\n    detectOgv,\n    detectWebm,\n\n    loadJson,\n    loadTxt,\n    loadWebFont,\n    loadSvg,\n    loadTextures,\n    loadVideoTextures,\n    loadBitmapFont,\n\n    bitmapFontCachePlugin,\n\n    resolveTextureUrl,\n    resolveJsonUrl\n);\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n"],"names":["Resolver","Loader","Cache","BackgroundLoader","warn","isSingleItem","convertToList","resolveResult","extensions","ExtensionType","cacheTextureArray","detectDefaults","detectAvif","detectWebp","detectMp4","detectOgv","detectWebm","loadJson","loadTxt","loadWebFont","loadSvg","loadTextures","loadVideoTextures","loadBitmapFont","bitmapFontCachePlugin","resolveTextureUrl","resolveJsonUrl"],"mappings":"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"}