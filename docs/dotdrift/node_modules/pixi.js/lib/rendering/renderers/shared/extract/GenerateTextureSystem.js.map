{"version":3,"file":"GenerateTextureSystem.js","sources":["../../../../../src/rendering/renderers/shared/extract/GenerateTextureSystem.ts"],"sourcesContent":["import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\n\n/**\n * Options for generating a texture source.\n * @category rendering\n * @advanced\n * @interface\n */\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * Used to create reusable textures from display objects, which can improve performance\n * when the same content needs to be rendered multiple times.\n * @example\n * ```ts\n * // Basic texture generation\n * const sprite = new Sprite(texture);\n * const generatedTexture = renderer.generateTexture({\n *     target: sprite\n * });\n *\n * // Generate with custom region and resolution\n * const texture = renderer.generateTexture({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // Generate with background color and anti-aliasing\n * const highQualityTexture = renderer.generateTexture({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     textureSourceOptions: {\n *         scaleMode: 'linear'\n *     }\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport type GenerateTextureOptions = {\n    /**\n     * The container to generate the texture from.\n     * This can be any display object like Sprite, Container, or Graphics.\n     * @example\n     * ```ts\n     * const graphics = new Graphics()\n     *     .circle(0, 0, 50)\n     *     .fill('red');\n     *\n     * const texture = renderer.generateTexture({\n     *     target: graphics\n     * });\n     * ```\n     */\n    target: Container;\n\n    /**\n     * The region of the container that should be rendered.\n     * If not specified, defaults to the local bounds of the container.\n     * @example\n     * ```ts\n     * // Extract only a portion of the container\n     * const texture = renderer.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the texture being generated.\n     * Higher values create sharper textures at the cost of memory.\n     * @default renderer.resolution\n     * @example\n     * ```ts\n     * // Generate a high-resolution texture\n     * const hiResTexture = renderer.generateTexture({\n     *     target: sprite,\n     *     resolution: 2 // 2x resolution\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the texture before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Generate a smooth texture\n     * const texture = renderer.generateTexture({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n\n    /**\n     * Advanced options for configuring the texture source.\n     * Controls texture properties like scale mode and filtering.\n     * @advanced\n     * @example\n     * ```ts\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     textureSourceOptions: {\n     *         scaleMode: 'linear',\n     *     }\n     * });\n     * ```\n     */\n    textureSourceOptions?: GenerateTextureSourceOptions;\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from display objects in the renderer.\n * This system is responsible for creating reusable textures from containers, sprites, and other display objects.\n * Available through `renderer.textureGenerator`.\n * @example\n * ```ts\n * import { Application, Sprite, Graphics } from 'pixi.js';\n *\n * const app = new Application();\n * await app.init();\n *\n * // Create a complex display object\n * const container = new Container();\n *\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill('red');\n *\n * const sprite = new Sprite(texture);\n * sprite.x = 100;\n *\n * container.addChild(graphics, sprite);\n *\n * // Generate a texture from the container\n * const generatedTexture = app.renderer.textureGenerator.generateTexture({\n *     target: container,\n *     resolution: 2,\n *     antialias: true\n * });\n *\n * // Use the generated texture\n * const newSprite = new Sprite(generatedTexture);\n * app.stage.addChild(newSprite);\n *\n * // Clean up when done\n * generatedTexture.destroy(true);\n * ```\n *\n * Features:\n * - Convert any display object to a texture\n * - Support for custom regions and resolutions\n * - Anti-aliasing support\n * - Background color configuration\n * - Texture source options customization\n *\n * Common Use Cases:\n * - Creating texture atlases dynamically\n * - Caching complex container content\n * - Generating thumbnails\n * - Creating reusable textures from rendered content\n *\n * Performance Considerations:\n * - Generating textures is relatively expensive\n * - Cache results when possible\n * - Be mindful of resolution and size\n * - Clean up unused textures\n * @see {@link GenerateTextureOptions} For detailed texture generation options\n * @see {@link AbstractRenderer.generateTexture} For the main renderer method\n * @see {@link RenderTexture} For the resulting texture type\n * @category rendering\n * @standard\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Creates a texture from a display object that can be used for creating sprites and other textures.\n     * This is particularly useful for optimizing performance when a complex container needs to be reused.\n     * @param options - Generate texture options or a container to convert to texture\n     * @returns A new RenderTexture containing the rendered display object\n     * @example\n     * ```ts\n     * // Basic usage with a container\n     * const container = new Container();\n     * container.addChild(\n     *     new Graphics()\n     *         .circle(0, 0, 50)\n     *         .fill('red')\n     * );\n     *\n     * const texture = renderer.textureGenerator.generateTexture(container);\n     *\n     * // Advanced usage with options\n     * const texture = renderer.textureGenerator.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n     *     resolution: 2,                        // High DPI\n     *     clearColor: '#ff0000',               // Red background\n     *     antialias: true                      // Smooth edges\n     * });\n     *\n     * // Create a sprite from the generated texture\n     * const sprite = new Sprite(texture);\n     *\n     * // Clean up when done\n     * texture.destroy(true);\n     * ```\n     * @see {@link GenerateTextureOptions} For detailed texture generation options\n     * @see {@link RenderTexture} For the type of texture created\n     * @category rendering\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): RenderTexture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        target.source.updateMipmaps();\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n"],"names":["Rectangle","Bounds","Container","Color","getLocalBounds","RenderTexture","Matrix","ExtensionType"],"mappings":"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"}