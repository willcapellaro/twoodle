{"version":3,"file":"GlLimitsSystem.mjs","sources":["../../../../src/rendering/renderers/gl/GlLimitsSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { checkMaxIfStatementsInShader } from '../../batcher/gl/utils/checkMaxIfStatementsInShader';\nimport { type System } from '../shared/system/System';\n\nimport type { WebGLRenderer } from './WebGLRenderer';\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the GL rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGlRenderer();\n * await renderer.init();\n *\n * console.log(renderer.limits.maxTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GlLimitsSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'limits',\n    } as const;\n\n    /** The maximum number of textures that can be used by a shader */\n    public maxTextures: number;\n    /** The maximum number of batchable textures */\n    public maxBatchableTextures: number;\n\n    /** The maximum number of uniform bindings */\n    public maxUniformBindings: number;\n\n    private readonly _renderer: WebGLRenderer;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public contextChange(): void\n    {\n        const gl = this._renderer.gl;\n\n        // step 1: first check max textures the GPU can handle.\n        this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        // step 2: check the maximum number of if statements the shader can have too..\n        this.maxBatchableTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);\n\n        // step 3: check the limit of uniform buffer bindings.\n        // UBs are available only in WebGL2 context, requesting within WebGL1 produces a warning.\n        const isWebGl2 = this._renderer.context.webGLVersion === 2;\n\n        this.maxUniformBindings = isWebGl2\n            ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS)\n            : 0;\n    }\n\n    public destroy(): void\n    {\n        // boom!\n    }\n}\n"],"names":[],"mappings":";;;;AA4BO,MAAM,cACb,CAAA;AAAA,EAmBI,YAAY,QACZ,EAAA;AACI,IAAA,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;AAAA,GACrB;AAAA,EAEO,aACP,GAAA;AACI,IAAM,MAAA,EAAA,GAAK,KAAK,SAAU,CAAA,EAAA,CAAA;AAG1B,IAAA,IAAA,CAAK,WAAc,GAAA,EAAA,CAAG,YAAa,CAAA,EAAA,CAAG,uBAAuB,CAAA,CAAA;AAG7D,IAAA,IAAA,CAAK,oBAAuB,GAAA,4BAAA,CAA6B,IAAK,CAAA,WAAA,EAAa,EAAE,CAAA,CAAA;AAI7E,IAAA,MAAM,QAAW,GAAA,IAAA,CAAK,SAAU,CAAA,OAAA,CAAQ,YAAiB,KAAA,CAAA,CAAA;AAEzD,IAAA,IAAA,CAAK,qBAAqB,QACpB,GAAA,EAAA,CAAG,YAAa,CAAA,EAAA,CAAG,2BAA2B,CAC9C,GAAA,CAAA,CAAA;AAAA,GACV;AAAA,EAEO,OACP,GAAA;AAAA,GAEA;AACJ,CAAA;AAAA;AAhDa,cAAA,CAGK,SAAY,GAAA;AAAA,EACtB,IAAM,EAAA;AAAA,IACF,aAAc,CAAA,WAAA;AAAA,GAClB;AAAA,EACA,IAAM,EAAA,QAAA;AACV,CAAA;;;;"}