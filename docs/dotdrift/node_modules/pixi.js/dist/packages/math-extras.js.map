{"version":3,"file":"math-extras.js","sources":["../../src/math-extras/pointExtras.ts","../../src/math-extras/rectangleExtras.ts","../../src/math-extras/init.ts","../../src/math-extras/util.ts"],"sourcesContent":["import { Point } from '../maths/point/Point';\n\nimport type { PointData } from '../maths/point/PointData';\n\n/** @internal */\nexport const pointExtraMixins: any = {\n    add<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x + other.x;\n        outPoint.y = this.y + other.y;\n\n        return outPoint;\n    },\n    subtract<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x - other.x;\n        outPoint.y = this.y - other.y;\n\n        return outPoint;\n    },\n    multiply<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x * other.x;\n        outPoint.y = this.y * other.y;\n\n        return outPoint;\n    },\n    multiplyScalar<T extends PointData>(scalar: number, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x * scalar;\n        outPoint.y = this.y * scalar;\n\n        return outPoint;\n    },\n    dot(other: PointData): number\n    {\n        return (this.x * other.x) + (this.y * other.y);\n    },\n    cross(other: PointData): number\n    {\n        /*\n         * Returns the magnitude of the vector that would result\n         * from a regular 3D cross product of the input vectors,\n         * taking their Z values implicitly as 0\n         * (i.e. treating the 2D space as a plane in the 3D space).\n         * The 3D cross product will be perpendicular to that plane,\n         * and thus have 0 X & Y components\n         * (thus the scalar returned is the Z value of the 3D cross product vector).\n         */\n        return (this.x * other.y) - (this.y * other.x);\n    },\n    normalize<T extends PointData>(outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        const magnitude = Math.sqrt((this.x * this.x) + (this.y * this.y));\n\n        outPoint.x = this.x / magnitude;\n        outPoint.y = this.y / magnitude;\n\n        return outPoint;\n    },\n    magnitude(): number\n    {\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\n    },\n    magnitudeSquared(): number\n    {\n        return (this.x * this.x) + (this.y * this.y);\n    },\n    project<T extends PointData>(onto: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        // Math says: a Projected over b = [(a·b) / (b·b)] * b;\n        const normalizedScalarProjection = ((this.x * onto.x) + (this.y * onto.y)) / ((onto.x * onto.x) + (onto.y * onto.y));\n\n        outPoint.x = onto.x * normalizedScalarProjection;\n        outPoint.y = onto.y * normalizedScalarProjection;\n\n        return outPoint;\n    },\n    reflect<T extends PointData>(normal: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n\n        // Given an incident vector i and a normal vector n, returns the reflection vector r = i - 2 * dot(i, n) * n\n\n        const dotProduct = (this.x * normal.x) + (this.y * normal.y);\n\n        outPoint.x = this.x - (2 * dotProduct * normal.x);\n        outPoint.y = this.y - (2 * dotProduct * normal.y);\n\n        return outPoint;\n    },\n    rotate<T extends PointData>(radians: number, outPoint?: T): T\n    {\n        outPoint ??= new Point() as PointData as T;\n\n        const cosTheta = Math.cos(radians);\n        const sinTheta = Math.sin(radians);\n\n        outPoint.x = (this.x * cosTheta) - (this.y * sinTheta);\n        outPoint.y = (this.x * sinTheta) + (this.y * cosTheta);\n\n        return outPoint;\n    }\n};\n","import { Rectangle } from '../maths/shapes/Rectangle';\n\n/** @internal */\nexport const rectangleExtraMixins: Partial<Rectangle> = {\n    containsRect(other: Rectangle): boolean\n    {\n        if (other.width <= 0 || other.height <= 0)\n        {\n            return other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom;\n        }\n\n        return other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;\n    },\n    equals(other: Rectangle): boolean\n    {\n        if (other === this)\n        {\n            return true;\n        }\n\n        return (\n            other\n            && this.x === other.x\n            && this.y === other.y\n            && this.width === other.width\n            && this.height === other.height\n        );\n    },\n    intersection<T extends Rectangle>(other: Rectangle, outRect?: T): T\n    {\n        if (!outRect)\n        {\n            outRect = new Rectangle() as T;\n        }\n\n        const x0 = this.x < other.x ? other.x : this.x;\n        const x1 = this.right > other.right ? other.right : this.right;\n\n        if (x1 <= x0)\n        {\n            outRect.x = outRect.y = outRect.width = outRect.height = 0;\n\n            return outRect;\n        }\n\n        const y0 = this.y < other.y ? other.y : this.y;\n        const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n        if (y1 <= y0)\n        {\n            outRect.x = outRect.y = outRect.width = outRect.height = 0;\n\n            return outRect;\n        }\n\n        outRect.x = x0;\n        outRect.y = y0;\n        outRect.width = x1 - x0;\n        outRect.height = y1 - y0;\n\n        return outRect;\n    },\n    union<T extends Rectangle>(other: Rectangle, outRect?: T): T\n    {\n        if (!outRect)\n        {\n            outRect = new Rectangle() as T;\n        }\n\n        const x1 = Math.min(this.x, other.x);\n        const x2 = Math.max(this.x + this.width, other.x + other.width);\n        const y1 = Math.min(this.y, other.y);\n        const y2 = Math.max(this.y + this.height, other.y + other.height);\n\n        outRect.x = x1;\n        outRect.y = y1;\n        outRect.width = x2 - x1;\n        outRect.height = y2 - y1;\n\n        return outRect;\n    },\n};\n","import { ObservablePoint } from '../maths/point/ObservablePoint';\nimport { Point } from '../maths/point/Point';\nimport { Rectangle } from '../maths/shapes/Rectangle';\nimport { pointExtraMixins } from './pointExtras';\nimport { rectangleExtraMixins } from './rectangleExtras';\n\nObject.assign(Point.prototype, pointExtraMixins);\nObject.assign(ObservablePoint.prototype, pointExtraMixins);\nObject.assign(Rectangle.prototype, rectangleExtraMixins);\n","import { Point } from '../maths/point/Point';\nimport './pointExtras';\nimport './rectangleExtras';\n\nimport type { PointData } from '../maths/point/PointData';\n\n/**\n * The idea of a relative epsilon comparison is to find the difference between the two numbers,\n * and see if it is less than a given epsilon.\n * A good epsilon would be the N% of the largest of the two values or `Math.EPSILON`.\n *\n * _Note: Only available with **pixi.js/math-extras**._\n * @param {number} a - First floating number to compare.\n * @param {number} b - Second floating number to compare.\n * @param {number} epsilon - The epsilon to compare to.\n * The larger the epsilon, the easier for the numbers to be considered equals.\n * @returns {boolean} Returns `true` if the difference between the values is less than the given epsilon;\n * otherwise `false`.\n * @category maths\n * @advanced\n */\nexport function floatEqual(a: number, b: number, epsilon: number = Number.EPSILON): boolean\n{\n    if (a === b)\n    {\n        return true;\n    }\n\n    const diff = Math.abs(a - b);\n\n    return diff < epsilon;\n}\n\n/**\n * Generic line or segment intersection.\n * A line can intersect outside the two points defining it, the segment can't.\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @param isLine - Set to true if you want Line (unbounded) intersection.\n * @param {PointData} [outPoint] - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {PointData} The point where the lines/segments intersect or a `NaN` Point.\n */\nfunction genericLineIntersection<T extends PointData>(\n    aStart: PointData,\n    aEnd: PointData,\n    bStart: PointData,\n    bEnd: PointData,\n    isLine: boolean,\n    outPoint?: T): T\n{\n    if (!outPoint)\n    {\n        outPoint = new Point() as PointData as T;\n    }\n\n    const dxa = aEnd.x - aStart.x;\n    const dya = aEnd.y - aStart.y;\n    const dxb = bEnd.x - bStart.x;\n    const dyb = bEnd.y - bStart.y;\n\n    // In order to find the position of the intersection in respect to the line segments, we can define lines\n    // in terms of first degree Bézier parameters, and find the two parameters `ua` and `ub` for the two lines to touch.\n    // both `ua` and `ub` formula share the same denominator so it is only calculated once.\n\n    const denominator = ((dyb * dxa) - (dxb * dya));\n\n    // If lines are parallel or overlapping, the intersection can be nowhere or everywhere... NaN.\n    if (floatEqual(denominator, 0))\n    {\n        outPoint.x = NaN;\n        outPoint.y = NaN;\n\n        return outPoint;\n    }\n\n    // ua is the factor of line a where the intersection occurs. ub is the factor of line b where the intersection occurs.\n    const ua = ((dxb * (aStart.y - bStart.y)) - (dyb * (aStart.x - bStart.x))) / denominator;\n    const ub = ((dxa * (aStart.y - bStart.y)) - (dya * (aStart.x - bStart.x))) / denominator;\n\n    // Line intersection extends beyond the bounds of the segment.\n    // The intersection is inside the segments if 0.0 ≤ ua ≤ 1.0 and 0.0 ≤ ub ≤ 1.0\n    if (!isLine && (ua < 0 || ua > 1 || ub < 0 || ub > 1))\n    {\n        outPoint.x = NaN;\n        outPoint.y = NaN;\n\n        return outPoint;\n    }\n\n    outPoint.x = aStart.x + (ua * dxa);\n    outPoint.y = bStart.y + (ub * dyb);\n\n    return outPoint;\n}\n\n/**\n * Computes the point where non-coincident and non-parallel Lines intersect.\n * Coincident or parallel lines return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point may land outside the extents of the lines.\n *\n * _Note: Only available with **pixi.js/math-extras**._\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @param {PointData} outPoint - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {PointData} The point where the lines intersect or a `NaN` Point.\n * @category maths\n * @advanced\n */\nexport function lineIntersection\n<T extends PointData = Point>(aStart: PointData, aEnd: PointData, bStart: PointData, bEnd: PointData, outPoint?: T): T\n{\n    return genericLineIntersection(aStart, aEnd, bStart, bEnd, true, outPoint);\n}\n\n/**\n * Computes the point where non-coincident and non-parallel segments intersect.\n * Coincident, parallel or non-intersecting segments return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point must land inside the extents of the segments or return a `NaN` Point.\n *\n * _Note: Only available with **pixi.js/math-extras**._\n * @param aStart - Starting point of the first segment.\n * @param aEnd - Ending point of the first segment.\n * @param bStart - Starting point of the second segment.\n * @param bEnd - Ending point of the second segment.\n * @param {PointData} outPoint - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {PointData} The point where the segments intersect or a `NaN` Point.\n * @category maths\n * @advanced\n */\nexport function segmentIntersection\n<T extends PointData = Point>(aStart: PointData, aEnd: PointData, bStart: PointData, bEnd: PointData, outPoint?: T): T\n{\n    return genericLineIntersection(aStart, aEnd, bStart, bEnd, false, outPoint);\n}\n"],"names":[],"mappings":"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"}