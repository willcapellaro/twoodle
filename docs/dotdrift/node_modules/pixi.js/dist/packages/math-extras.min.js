/*!
 * PixiJS - v8.14.0
 * Compiled Mon, 06 Oct 2025 21:31:20 UTC
 *
 * PixiJS is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */this.PIXI=this.PIXI||{};var math_extras_js=function(s){"use strict";"use strict";const x={add(t,i){return i||(i=new PIXI.Point),i.x=this.x+t.x,i.y=this.y+t.y,i},subtract(t,i){return i||(i=new PIXI.Point),i.x=this.x-t.x,i.y=this.y-t.y,i},multiply(t,i){return i||(i=new PIXI.Point),i.x=this.x*t.x,i.y=this.y*t.y,i},multiplyScalar(t,i){return i||(i=new PIXI.Point),i.x=this.x*t,i.y=this.y*t,i},dot(t){return this.x*t.x+this.y*t.y},cross(t){return this.x*t.y-this.y*t.x},normalize(t){t||(t=new PIXI.Point);const i=Math.sqrt(this.x*this.x+this.y*this.y);return t.x=this.x/i,t.y=this.y/i,t},magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)},magnitudeSquared(){return this.x*this.x+this.y*this.y},project(t,i){i||(i=new PIXI.Point);const h=(this.x*t.x+this.y*t.y)/(t.x*t.x+t.y*t.y);return i.x=t.x*h,i.y=t.y*h,i},reflect(t,i){i||(i=new PIXI.Point);const h=this.x*t.x+this.y*t.y;return i.x=this.x-2*h*t.x,i.y=this.y-2*h*t.y,i},rotate(t,i){i!=null||(i=new PIXI.Point);const h=Math.cos(t),e=Math.sin(t);return i.x=this.x*h-this.y*e,i.y=this.x*e+this.y*h,i}},g={containsRect(t){return t.width<=0||t.height<=0?t.x>this.x&&t.y>this.y&&t.right<this.right&&t.bottom<this.bottom:t.x>=this.x&&t.y>=this.y&&t.right<=this.right&&t.bottom<=this.bottom},equals(t){return t===this?!0:t&&this.x===t.x&&this.y===t.y&&this.width===t.width&&this.height===t.height},intersection(t,i){i||(i=new PIXI.Rectangle);const h=this.x<t.x?t.x:this.x,e=this.right>t.right?t.right:this.right;if(e<=h)return i.x=i.y=i.width=i.height=0,i;const r=this.y<t.y?t.y:this.y,n=this.bottom>t.bottom?t.bottom:this.bottom;return n<=r?(i.x=i.y=i.width=i.height=0,i):(i.x=h,i.y=r,i.width=e-h,i.height=n-r,i)},union(t,i){i||(i=new PIXI.Rectangle);const h=Math.min(this.x,t.x),e=Math.max(this.x+this.width,t.x+t.width),r=Math.min(this.y,t.y),n=Math.max(this.y+this.height,t.y+t.height);return i.x=h,i.y=r,i.width=e-h,i.height=n-r,i}};Object.assign(PIXI.Point.prototype,x),Object.assign(PIXI.ObservablePoint.prototype,x),Object.assign(PIXI.Rectangle.prototype,g);function P(t,i,h=Number.EPSILON){return t===i?!0:Math.abs(t-i)<h}function l(t,i,h,e,r,n){n||(n=new PIXI.Point);const y=i.x-t.x,m=i.y-t.y,w=e.x-h.x,o=e.y-h.y,u=o*y-w*m;if(P(u,0))return n.x=NaN,n.y=NaN,n;const c=(w*(t.y-h.y)-o*(t.x-h.x))/u,I=(y*(t.y-h.y)-m*(t.x-h.x))/u;return!r&&(c<0||c>1||I<0||I>1)?(n.x=NaN,n.y=NaN,n):(n.x=t.x+c*y,n.y=h.y+I*o,n)}function a(t,i,h,e,r){return l(t,i,h,e,!0,r)}function b(t,i,h,e,r){return l(t,i,h,e,!1,r)}return s.floatEqual=P,s.lineIntersection=a,s.pointExtraMixins=x,s.rectangleExtraMixins=g,s.segmentIntersection=b,s}({});Object.assign(this.PIXI,math_extras_js);
//# sourceMappingURL=math-extras.min.js.map
