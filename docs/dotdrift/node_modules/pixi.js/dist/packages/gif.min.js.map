{"version":3,"file":"gif.min.js","sources":["../../node_modules/js-binary-schema-parser/lib/index.js","../../node_modules/js-binary-schema-parser/lib/parsers/uint8.js","../../node_modules/js-binary-schema-parser/lib/schemas/gif.js","../../node_modules/gifuct-js/lib/deinterlace.js","../../node_modules/gifuct-js/lib/lzw.js","../../node_modules/gifuct-js/lib/index.js","../../src/gif/GifSource.ts","../../src/gif/GifAsset.ts","../../src/gif/GifSprite.ts","../../src/gif/init.ts"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loop = exports.conditional = exports.parse = void 0;\n\nvar parse = function parse(stream, schema) {\n  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : result;\n\n  if (Array.isArray(schema)) {\n    schema.forEach(function (partSchema) {\n      return parse(stream, partSchema, result, parent);\n    });\n  } else if (typeof schema === 'function') {\n    schema(stream, result, parent, parse);\n  } else {\n    var key = Object.keys(schema)[0];\n\n    if (Array.isArray(schema[key])) {\n      parent[key] = {};\n      parse(stream, schema[key], result, parent[key]);\n    } else {\n      parent[key] = schema[key](stream, result, parent, parse);\n    }\n  }\n\n  return result;\n};\n\nexports.parse = parse;\n\nvar conditional = function conditional(schema, conditionFunc) {\n  return function (stream, result, parent, parse) {\n    if (conditionFunc(stream, result, parent)) {\n      parse(stream, schema, result, parent);\n    }\n  };\n};\n\nexports.conditional = conditional;\n\nvar loop = function loop(schema, continueFunc) {\n  return function (stream, result, parent, parse) {\n    var arr = [];\n    var lastStreamPos = stream.pos;\n\n    while (continueFunc(stream, result, parent)) {\n      var newParent = {};\n      parse(stream, schema, result, newParent); // cases when whole file is parsed but no termination is there and stream position is not getting updated as well\n      // it falls into infinite recursion, null check to avoid the same\n\n      if (stream.pos === lastStreamPos) {\n        break;\n      }\n\n      lastStreamPos = stream.pos;\n      arr.push(newParent);\n    }\n\n    return arr;\n  };\n};\n\nexports.loop = loop;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readBits = exports.readArray = exports.readUnsigned = exports.readString = exports.peekBytes = exports.readBytes = exports.peekByte = exports.readByte = exports.buildStream = void 0;\n\n// Default stream and parsers for Uint8TypedArray data type\nvar buildStream = function buildStream(uint8Data) {\n  return {\n    data: uint8Data,\n    pos: 0\n  };\n};\n\nexports.buildStream = buildStream;\n\nvar readByte = function readByte() {\n  return function (stream) {\n    return stream.data[stream.pos++];\n  };\n};\n\nexports.readByte = readByte;\n\nvar peekByte = function peekByte() {\n  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return function (stream) {\n    return stream.data[stream.pos + offset];\n  };\n};\n\nexports.peekByte = peekByte;\n\nvar readBytes = function readBytes(length) {\n  return function (stream) {\n    return stream.data.subarray(stream.pos, stream.pos += length);\n  };\n};\n\nexports.readBytes = readBytes;\n\nvar peekBytes = function peekBytes(length) {\n  return function (stream) {\n    return stream.data.subarray(stream.pos, stream.pos + length);\n  };\n};\n\nexports.peekBytes = peekBytes;\n\nvar readString = function readString(length) {\n  return function (stream) {\n    return Array.from(readBytes(length)(stream)).map(function (value) {\n      return String.fromCharCode(value);\n    }).join('');\n  };\n};\n\nexports.readString = readString;\n\nvar readUnsigned = function readUnsigned(littleEndian) {\n  return function (stream) {\n    var bytes = readBytes(2)(stream);\n    return littleEndian ? (bytes[1] << 8) + bytes[0] : (bytes[0] << 8) + bytes[1];\n  };\n};\n\nexports.readUnsigned = readUnsigned;\n\nvar readArray = function readArray(byteSize, totalOrFunc) {\n  return function (stream, result, parent) {\n    var total = typeof totalOrFunc === 'function' ? totalOrFunc(stream, result, parent) : totalOrFunc;\n    var parser = readBytes(byteSize);\n    var arr = new Array(total);\n\n    for (var i = 0; i < total; i++) {\n      arr[i] = parser(stream);\n    }\n\n    return arr;\n  };\n};\n\nexports.readArray = readArray;\n\nvar subBitsTotal = function subBitsTotal(bits, startIndex, length) {\n  var result = 0;\n\n  for (var i = 0; i < length; i++) {\n    result += bits[startIndex + i] && Math.pow(2, length - i - 1);\n  }\n\n  return result;\n};\n\nvar readBits = function readBits(schema) {\n  return function (stream) {\n    var _byte = readByte()(stream); // convert the byte to bit array\n\n\n    var bits = new Array(8);\n\n    for (var i = 0; i < 8; i++) {\n      bits[7 - i] = !!(_byte & 1 << i);\n    } // convert the bit array to values based on the schema\n\n\n    return Object.keys(schema).reduce(function (res, key) {\n      var def = schema[key];\n\n      if (def.length) {\n        res[key] = subBitsTotal(bits, def.index, def.length);\n      } else {\n        res[key] = bits[def.index];\n      }\n\n      return res;\n    }, {});\n  };\n};\n\nexports.readBits = readBits;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _ = require(\"../\");\n\nvar _uint = require(\"../parsers/uint8\");\n\n// a set of 0x00 terminated subblocks\nvar subBlocksSchema = {\n  blocks: function blocks(stream) {\n    var terminator = 0x00;\n    var chunks = [];\n    var streamSize = stream.data.length;\n    var total = 0;\n\n    for (var size = (0, _uint.readByte)()(stream); size !== terminator; size = (0, _uint.readByte)()(stream)) {\n      // size becomes undefined for some case when file is corrupted and  terminator is not proper \n      // null check to avoid recursion\n      if (!size) break; // catch corrupted files with no terminator\n\n      if (stream.pos + size >= streamSize) {\n        var availableSize = streamSize - stream.pos;\n        chunks.push((0, _uint.readBytes)(availableSize)(stream));\n        total += availableSize;\n        break;\n      }\n\n      chunks.push((0, _uint.readBytes)(size)(stream));\n      total += size;\n    }\n\n    var result = new Uint8Array(total);\n    var offset = 0;\n\n    for (var i = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset);\n      offset += chunks[i].length;\n    }\n\n    return result;\n  }\n}; // global control extension\n\nvar gceSchema = (0, _.conditional)({\n  gce: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    byteSize: (0, _uint.readByte)()\n  }, {\n    extras: (0, _uint.readBits)({\n      future: {\n        index: 0,\n        length: 3\n      },\n      disposal: {\n        index: 3,\n        length: 3\n      },\n      userInput: {\n        index: 6\n      },\n      transparentColorGiven: {\n        index: 7\n      }\n    })\n  }, {\n    delay: (0, _uint.readUnsigned)(true)\n  }, {\n    transparentColorIndex: (0, _uint.readByte)()\n  }, {\n    terminator: (0, _uint.readByte)()\n  }]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xf9;\n}); // image pipeline block\n\nvar imageSchema = (0, _.conditional)({\n  image: [{\n    code: (0, _uint.readByte)()\n  }, {\n    descriptor: [{\n      left: (0, _uint.readUnsigned)(true)\n    }, {\n      top: (0, _uint.readUnsigned)(true)\n    }, {\n      width: (0, _uint.readUnsigned)(true)\n    }, {\n      height: (0, _uint.readUnsigned)(true)\n    }, {\n      lct: (0, _uint.readBits)({\n        exists: {\n          index: 0\n        },\n        interlaced: {\n          index: 1\n        },\n        sort: {\n          index: 2\n        },\n        future: {\n          index: 3,\n          length: 2\n        },\n        size: {\n          index: 5,\n          length: 3\n        }\n      })\n    }]\n  }, (0, _.conditional)({\n    lct: (0, _uint.readArray)(3, function (stream, result, parent) {\n      return Math.pow(2, parent.descriptor.lct.size + 1);\n    })\n  }, function (stream, result, parent) {\n    return parent.descriptor.lct.exists;\n  }), {\n    data: [{\n      minCodeSize: (0, _uint.readByte)()\n    }, subBlocksSchema]\n  }]\n}, function (stream) {\n  return (0, _uint.peekByte)()(stream) === 0x2c;\n}); // plain text block\n\nvar textSchema = (0, _.conditional)({\n  text: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    blockSize: (0, _uint.readByte)()\n  }, {\n    preData: function preData(stream, result, parent) {\n      return (0, _uint.readBytes)(parent.text.blockSize)(stream);\n    }\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0x01;\n}); // application block\n\nvar applicationSchema = (0, _.conditional)({\n  application: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    blockSize: (0, _uint.readByte)()\n  }, {\n    id: function id(stream, result, parent) {\n      return (0, _uint.readString)(parent.blockSize)(stream);\n    }\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xff;\n}); // comment block\n\nvar commentSchema = (0, _.conditional)({\n  comment: [{\n    codes: (0, _uint.readBytes)(2)\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xfe;\n});\nvar schema = [{\n  header: [{\n    signature: (0, _uint.readString)(3)\n  }, {\n    version: (0, _uint.readString)(3)\n  }]\n}, {\n  lsd: [{\n    width: (0, _uint.readUnsigned)(true)\n  }, {\n    height: (0, _uint.readUnsigned)(true)\n  }, {\n    gct: (0, _uint.readBits)({\n      exists: {\n        index: 0\n      },\n      resolution: {\n        index: 1,\n        length: 3\n      },\n      sort: {\n        index: 4\n      },\n      size: {\n        index: 5,\n        length: 3\n      }\n    })\n  }, {\n    backgroundColorIndex: (0, _uint.readByte)()\n  }, {\n    pixelAspectRatio: (0, _uint.readByte)()\n  }]\n}, (0, _.conditional)({\n  gct: (0, _uint.readArray)(3, function (stream, result) {\n    return Math.pow(2, result.lsd.gct.size + 1);\n  })\n}, function (stream, result) {\n  return result.lsd.gct.exists;\n}), // content frames\n{\n  frames: (0, _.loop)([gceSchema, applicationSchema, commentSchema, imageSchema, textSchema], function (stream) {\n    var nextCode = (0, _uint.peekByte)()(stream); // rather than check for a terminator, we should check for the existence\n    // of an ext or image block to avoid infinite loops\n    //var terminator = 0x3B;\n    //return nextCode !== terminator;\n\n    return nextCode === 0x21 || nextCode === 0x2c;\n  })\n}];\nvar _default = schema;\nexports[\"default\"] = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deinterlace = void 0;\n\n/**\r\n * Deinterlace function from https://github.com/shachaf/jsgif\r\n */\nvar deinterlace = function deinterlace(pixels, width) {\n  var newPixels = new Array(pixels.length);\n  var rows = pixels.length / width;\n\n  var cpRow = function cpRow(toRow, fromRow) {\n    var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\n    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\n  }; // See appendix E.\n\n\n  var offsets = [0, 4, 2, 1];\n  var steps = [8, 8, 4, 2];\n  var fromRow = 0;\n\n  for (var pass = 0; pass < 4; pass++) {\n    for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\n      cpRow(toRow, fromRow);\n      fromRow++;\n    }\n  }\n\n  return newPixels;\n};\n\nexports.deinterlace = deinterlace;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lzw = void 0;\n\n/**\r\n * javascript port of java LZW decompression\r\n * Original java author url: https://gist.github.com/devunwired/4479231\r\n */\nvar lzw = function lzw(minCodeSize, data, pixelCount) {\n  var MAX_STACK_SIZE = 4096;\n  var nullCode = -1;\n  var npix = pixelCount;\n  var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;\n  var dstPixels = new Array(pixelCount);\n  var prefix = new Array(MAX_STACK_SIZE);\n  var suffix = new Array(MAX_STACK_SIZE);\n  var pixelStack = new Array(MAX_STACK_SIZE + 1); // Initialize GIF data stream decoder.\n\n  data_size = minCodeSize;\n  clear = 1 << data_size;\n  end_of_information = clear + 1;\n  available = clear + 2;\n  old_code = nullCode;\n  code_size = data_size + 1;\n  code_mask = (1 << code_size) - 1;\n\n  for (code = 0; code < clear; code++) {\n    prefix[code] = 0;\n    suffix[code] = code;\n  } // Decode GIF pixel stream.\n\n\n  var datum, bits, count, first, top, pi, bi;\n  datum = bits = count = first = top = pi = bi = 0;\n\n  for (i = 0; i < npix;) {\n    if (top === 0) {\n      if (bits < code_size) {\n        // get the next byte\n        datum += data[bi] << bits;\n        bits += 8;\n        bi++;\n        continue;\n      } // Get the next code.\n\n\n      code = datum & code_mask;\n      datum >>= code_size;\n      bits -= code_size; // Interpret the code\n\n      if (code > available || code == end_of_information) {\n        break;\n      }\n\n      if (code == clear) {\n        // Reset decoder.\n        code_size = data_size + 1;\n        code_mask = (1 << code_size) - 1;\n        available = clear + 2;\n        old_code = nullCode;\n        continue;\n      }\n\n      if (old_code == nullCode) {\n        pixelStack[top++] = suffix[code];\n        old_code = code;\n        first = code;\n        continue;\n      }\n\n      in_code = code;\n\n      if (code == available) {\n        pixelStack[top++] = first;\n        code = old_code;\n      }\n\n      while (code > clear) {\n        pixelStack[top++] = suffix[code];\n        code = prefix[code];\n      }\n\n      first = suffix[code] & 0xff;\n      pixelStack[top++] = first; // add a new string to the table, but only if space is available\n      // if not, just continue with current table until a clear code is found\n      // (deferred clear code implementation as per GIF spec)\n\n      if (available < MAX_STACK_SIZE) {\n        prefix[available] = old_code;\n        suffix[available] = first;\n        available++;\n\n        if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {\n          code_size++;\n          code_mask += available;\n        }\n      }\n\n      old_code = in_code;\n    } // Pop a pixel off the pixel stack.\n\n\n    top--;\n    dstPixels[pi++] = pixelStack[top];\n    i++;\n  }\n\n  for (i = pi; i < npix; i++) {\n    dstPixels[i] = 0; // clear missing pixels\n  }\n\n  return dstPixels;\n};\n\nexports.lzw = lzw;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompressFrames = exports.decompressFrame = exports.parseGIF = void 0;\n\nvar _gif = _interopRequireDefault(require(\"js-binary-schema-parser/lib/schemas/gif\"));\n\nvar _jsBinarySchemaParser = require(\"js-binary-schema-parser\");\n\nvar _uint = require(\"js-binary-schema-parser/lib/parsers/uint8\");\n\nvar _deinterlace = require(\"./deinterlace\");\n\nvar _lzw = require(\"./lzw\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar parseGIF = function parseGIF(arrayBuffer) {\n  var byteData = new Uint8Array(arrayBuffer);\n  return (0, _jsBinarySchemaParser.parse)((0, _uint.buildStream)(byteData), _gif[\"default\"]);\n};\n\nexports.parseGIF = parseGIF;\n\nvar generatePatch = function generatePatch(image) {\n  var totalPixels = image.pixels.length;\n  var patchData = new Uint8ClampedArray(totalPixels * 4);\n\n  for (var i = 0; i < totalPixels; i++) {\n    var pos = i * 4;\n    var colorIndex = image.pixels[i];\n    var color = image.colorTable[colorIndex] || [0, 0, 0];\n    patchData[pos] = color[0];\n    patchData[pos + 1] = color[1];\n    patchData[pos + 2] = color[2];\n    patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;\n  }\n\n  return patchData;\n};\n\nvar decompressFrame = function decompressFrame(frame, gct, buildImagePatch) {\n  if (!frame.image) {\n    console.warn('gif frame does not have associated image.');\n    return;\n  }\n\n  var image = frame.image; // get the number of pixels\n\n  var totalPixels = image.descriptor.width * image.descriptor.height; // do lzw decompression\n\n  var pixels = (0, _lzw.lzw)(image.data.minCodeSize, image.data.blocks, totalPixels); // deal with interlacing if necessary\n\n  if (image.descriptor.lct.interlaced) {\n    pixels = (0, _deinterlace.deinterlace)(pixels, image.descriptor.width);\n  }\n\n  var resultImage = {\n    pixels: pixels,\n    dims: {\n      top: frame.image.descriptor.top,\n      left: frame.image.descriptor.left,\n      width: frame.image.descriptor.width,\n      height: frame.image.descriptor.height\n    }\n  }; // color table\n\n  if (image.descriptor.lct && image.descriptor.lct.exists) {\n    resultImage.colorTable = image.lct;\n  } else {\n    resultImage.colorTable = gct;\n  } // add per frame relevant gce information\n\n\n  if (frame.gce) {\n    resultImage.delay = (frame.gce.delay || 10) * 10; // convert to ms\n\n    resultImage.disposalType = frame.gce.extras.disposal; // transparency\n\n    if (frame.gce.extras.transparentColorGiven) {\n      resultImage.transparentIndex = frame.gce.transparentColorIndex;\n    }\n  } // create canvas usable imagedata if desired\n\n\n  if (buildImagePatch) {\n    resultImage.patch = generatePatch(resultImage);\n  }\n\n  return resultImage;\n};\n\nexports.decompressFrame = decompressFrame;\n\nvar decompressFrames = function decompressFrames(parsedGif, buildImagePatches) {\n  return parsedGif.frames.filter(function (f) {\n    return f.image;\n  }).map(function (f) {\n    return decompressFrame(f, parsedGif.gct, buildImagePatches);\n  });\n};\n\nexports.decompressFrames = decompressFrames;","import { decompressFrames, type ParsedFrame, parseGIF } from 'gifuct-js';\nimport { DOMAdapter } from '../environment/adapter';\nimport { CanvasSource, type CanvasSourceOptions } from '../rendering/renderers/shared/texture/sources/CanvasSource';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\n/**\n * Represents a single frame of a GIF. Includes image and timing data.\n * @category gif\n * @advanced\n */\ninterface GifFrame\n{\n    /** Image data for the current frame */\n    texture: Texture<CanvasSource>;\n    /** The start of the current frame, in milliseconds */\n    start: number;\n    /** The end of the current frame, in milliseconds */\n    end: number;\n}\n\n/**\n * Options when constructing from buffer\n * @category gif\n * @advanced\n */\ninterface GifBufferOptions extends Omit<CanvasSourceOptions, 'resource'>\n{\n    /** FPS to use when the GIF animation doesn't define any delay between frames */\n    fps?: number;\n}\n\n/**\n * Resource provided to GifSprite instances. This is very similar to using a shared\n * Texture between Sprites. This source contains all the frames and animation needed\n * to support playback.\n * @category gif\n * @advanced\n */\nclass GifSource\n{\n    /** Width of the animation */\n    public readonly width: number;\n\n    /** Height of the animation */\n    public readonly height: number;\n\n    /** The total time to play the animation in milliseconds */\n    public readonly duration: number;\n\n    /** Animation frames */\n    public readonly frames: GifFrame[];\n\n    /** Textures */\n    public readonly textures: Texture<CanvasSource>[];\n\n    /** Total number of frames in the animation */\n    public readonly totalFrames: number;\n\n    /**\n     * @param frames - Array of GifFrame instances.\n     */\n    constructor(frames: GifFrame[])\n    {\n        // #if _DEBUG\n        if (!frames || !frames.length) throw new Error('Invalid frames');\n        // #endif\n\n        // All frames are the same size, get the first frame's size\n        const [{ texture: { width, height } }] = frames;\n\n        this.width = width;\n        this.height = height;\n        this.frames = frames;\n        this.textures = this.frames.map((frame) => frame.texture);\n        this.totalFrames = this.frames.length;\n        this.duration = this.frames[this.totalFrames - 1].end;\n    }\n\n    /** Destroy animation data and don't use after this */\n    public destroy()\n    {\n        for (const texture of this.textures)\n        {\n            texture.destroy(true);\n        }\n        for (const frame of this.frames)\n        {\n            frame.texture = null;\n        }\n        this.frames.length = 0;\n        this.textures.length = 0;\n        Object.assign(this, {\n            frames: null,\n            textures: null,\n            width: 0,\n            height: 0,\n            duration: 0,\n            totalFrames: 0,\n        });\n    }\n\n    /**\n     * Create an animated GIF animation from a GIF image's ArrayBuffer. The easiest way to get\n     * the buffer is to use Assets.\n     * @example\n     * import { GifSource, GifSprite } from 'pixi.js/gif';\n     *\n     * const buffer = await fetch('./file.gif').then(res => res.arrayBuffer());\n     * const source = GifSource.from(buffer);\n     * const sprite = new GifSprite(source);\n     * @param buffer - GIF image arraybuffer from Assets.\n     * @param options - Optional options to use when building from buffer.\n     */\n    public static from(buffer: ArrayBuffer, options?: GifBufferOptions): GifSource\n    {\n        if (!buffer || buffer.byteLength === 0)\n        {\n            throw new Error('Invalid buffer');\n        }\n\n        // fix https://github.com/matt-way/gifuct-js/issues/30\n        const validateAndFix = (gif: any): void =>\n        {\n            let currentGce = null;\n\n            for (const frame of gif.frames)\n            {\n                currentGce = frame.gce ?? currentGce;\n\n                // fix loosing graphic control extension for same frames\n                if ('image' in frame && !('gce' in frame))\n                {\n                    frame.gce = currentGce;\n                }\n            }\n        };\n\n        const gif = parseGIF(buffer);\n\n        validateAndFix(gif);\n        const gifFrames = decompressFrames(gif, true);\n        const frames: GifFrame[] = [];\n        const animWidth = gif.lsd.width;\n        const animHeight = gif.lsd.height;\n\n        // Temporary canvases required for compositing frames\n        const canvas = DOMAdapter.get().createCanvas(animWidth, animHeight);\n        const context = canvas.getContext('2d', { willReadFrequently: true });\n        const patchCanvas = DOMAdapter.get().createCanvas();\n        const patchContext = patchCanvas.getContext('2d');\n\n        let time = 0;\n        let previousFrame: ImageData | null = null;\n\n        // Some GIFs have a non-zero frame delay, so we need to calculate the fallback\n        const { fps = 30, ...canvasSourceOptions } = options ?? {};\n        const defaultDelay = 1000 / fps;\n\n        // Precompute each frame and store as ImageData\n        for (let i = 0; i < gifFrames.length; i++)\n        {\n            // Some GIF's omit the disposalType, so let's assume clear if missing\n            const {\n                disposalType = 2,\n                delay = defaultDelay,\n                patch,\n                dims: { width, height, left, top },\n            } = gifFrames[i] as ParsedFrame;\n\n            patchCanvas.width = width;\n            patchCanvas.height = height;\n            patchContext.clearRect(0, 0, width, height);\n            const patchData = patchContext.createImageData(width, height);\n\n            patchData.data.set(patch);\n            patchContext.putImageData(patchData, 0, 0);\n\n            if (disposalType === 3)\n            {\n                previousFrame = context.getImageData(0, 0, animWidth, animHeight);\n            }\n\n            context.drawImage(patchCanvas as CanvasImageSource, left, top);\n            const imageData = context.getImageData(0, 0, animWidth, animHeight);\n\n            if (disposalType === 2)\n            {\n                context.clearRect(0, 0, animWidth, animHeight);\n            }\n            else if (disposalType === 3)\n            {\n                context.putImageData(previousFrame as ImageData, 0, 0);\n            }\n\n            // Create new texture\n            const resource = DOMAdapter.get().createCanvas(\n                imageData.width,\n                imageData.height\n            ) as HTMLCanvasElement;\n            const resourceContext = resource.getContext('2d');\n\n            resourceContext.putImageData(imageData, 0, 0);\n\n            frames.push({\n                start: time,\n                end: time + delay,\n                texture: new Texture({\n                    source: new CanvasSource({\n                        resource,\n                        ...canvasSourceOptions,\n                    }),\n                }),\n            });\n            time += delay;\n        }\n\n        // clear the canvases\n        canvas.width = canvas.height = 0;\n        patchCanvas.width = patchCanvas.height = 0;\n\n        return new GifSource(frames);\n    }\n}\n\nexport { GifBufferOptions, GifFrame, GifSource };\n","import { DOMAdapter } from '../environment/adapter';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { path } from '../utils/path';\nimport { type GifBufferOptions, GifSource } from './GifSource';\n\nimport type { AssetExtension } from '../assets/AssetExtension';\n\n/**\n * Handle the loading of GIF images. Registering this loader plugin will\n * load all `.gif` images as an ArrayBuffer and transform into an\n * GifSource object.\n * @category gif\n * @advanced\n */\nconst GifAsset: AssetExtension<GifSource, GifBufferOptions> = {\n    extension: ExtensionType.Asset,\n    detection: {\n        test: async () => true,\n        add: async (formats) => [...formats, 'gif'],\n        remove: async (formats) => formats.filter((format) => format !== 'gif'),\n    },\n    loader: {\n        /** used for deprecation purposes */\n        name: 'gifLoader',\n        id: 'gif',\n        test: (url) => path.extname(url) === '.gif' || url.startsWith('data:image/gif'),\n        load: async (url, asset) =>\n        {\n            const response = await DOMAdapter.get().fetch(url);\n            const buffer = await response.arrayBuffer();\n\n            return GifSource.from(buffer, asset?.data);\n        },\n        unload: async (asset) =>\n        {\n            asset.destroy();\n        },\n    }\n};\n\nexport { GifAsset };\n","import { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { Sprite, type SpriteOptions } from '../scene/sprite/Sprite';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\nimport { GifSource } from './GifSource';\n\nimport type { SCALE_MODE } from '../rendering/renderers/shared/texture/const';\n\n/**\n * Configuration options for creating a GifSprite instance.\n *\n * These options control both the visual appearance and playback behavior\n * of animated GIFs.\n * @example Minimal Usage\n * ```ts\n * import { Assets } from 'pixi.js';\n * import { GifSprite } from 'pixi.js/gif';\n *\n * // Simple usage, minimal options\n * const source = await Assets.load('animation.gif');\n * const animation = new GifSprite(source);\n * ```\n * @example Advanced Options\n * ```ts\n * import { Assets } from 'pixi.js';\n * import { GifSprite } from 'pixi.js/gif';\n *\n * // Advanced usage with options\n * const source = await Assets.load({\n *   src: 'animation.gif',\n *   data: {\n *     scaleMode: 'nearest'  // Pixelated scaling\n *   }\n * });\n *\n * const animation = new GifSprite({\n *   source,                 // GIF data source\n *   animationSpeed: 1.5,    // 50% faster than normal\n *   loop: true,             // Loop the animation\n *   autoPlay: true,         // Start playing immediately\n *   onComplete() {          // Called when non-looping animation ends\n *     console.log('Animation complete!');\n *   }\n * });\n * ```\n * @category gif\n * @standard\n */\ninterface GifSpriteOptions extends Omit<SpriteOptions, 'texture'>\n{\n    /**\n     * Source containing the GIF frame and animation data\n     * @see {@link GifSource}\n     * @example\n     * ```ts\n     * const source = await Assets.load('animation.gif');\n     * const animation = new GifSprite({ source });\n     * ```\n     */\n    source: GifSource;\n    /**\n     * Whether to start playing right away when created.\n     * If `false`, you must call {@link GifSprite.play} to start playback.\n     * @default true\n     * @example\n     * ```ts\n     * const animation = new GifSprite({ source, autoPlay: true });\n     * ```\n     * @see {@link GifSprite.play}\n     */\n    autoPlay?: boolean;\n    /**\n     * This is not implemented and you should, instead, use `scaleMode`\n     * when loading the Asset as an option for the UnresolvedAsset's `data`.\n     * @type {SCALE_MODE}\n     * @default 'linear'\n     * @deprecated since 8.13.0\n     */\n    scaleMode?: SCALE_MODE;\n    /**\n     * Whether to loop the animation.\n     * If `false`, the animation will stop after the last frame.\n     * @default true\n     * @example\n     * ```ts\n     * const animation = new GifSprite({ source, loop: false });\n     * ```\n     */\n    loop?: boolean;\n    /**\n     * Animation playback speed multiplier.\n     * Higher values speed up the animation, lower values slow it down.\n     * @default 1\n     * @example\n     * ```ts\n     * const animation = new GifSprite({ source, animationSpeed: 2 }); // 2x speed\n     * ```\n     * @see {@link GifSprite.play}\n     * @see {@link GifSprite.stop}\n     */\n    animationSpeed?: number;\n    /**\n     * Whether to auto-update animation via shared ticker.\n     * Set to `false` to manage updates yourself.\n     * @default true\n     * @example\n     * ```ts\n     * const animation = new GifSprite({ source, autoUpdate: false });\n     * // Manage updates manually:\n     * app.ticker.add((ticker) => {\n     *     animation.update(ticker);\n     * });\n     * ```\n     */\n    autoUpdate?: boolean;\n    /**\n     * Callback when non-looping animation completes.\n     * This is only called if `loop` is set to `false`.\n     * If `loop` is `true`, use {@link GifSprite.onLoop} instead.\n     * @default null\n     * @example\n     * ```ts\n     * const animation = new GifSprite({\n     *     source,\n     *     onComplete: () => {\n     *         console.log('Animation finished!');\n     *     }\n     * });\n     * ```\n     * @see {@link GifSprite.play}\n     * @see {@link GifSprite.stop}\n     */\n    onComplete?: null | (() => void);\n    /**\n     * Callback when looping animation completes a loop.\n     * @default null\n     * @example\n     * ```ts\n     * const animation = new GifSprite({\n     *     source,\n     *     onLoop: () => {\n     *         console.log('Animation looped!');\n     *     }\n     * });\n     * ```\n     * @see {@link GifSprite.play}\n     * @see {@link GifSprite.stop}\n     */\n    onLoop?: null | (() => void);\n    /**\n     * Callback when animation frame changes.\n     * This is called every time the current frame changes,\n     * allowing you to respond to frame changes in real-time.\n     * @default null\n     * @example\n     * ```ts\n     * const animation = new GifSprite({\n     *     source,\n     *     onFrameChange: (currentFrame) => {\n     *         console.log(`Current frame: ${currentFrame}`);\n     *     }\n     * });\n     * ```\n     * @see {@link GifSprite.currentFrame}\n     * @see {@link GifSprite.play}\n     * @see {@link GifSprite.stop}\n     */\n    onFrameChange?: null | ((currentFrame: number) => void);\n    /**\n     * Fallback FPS if GIF contains no timing information\n     * @default 30\n     * @example\n     * ```ts\n     * const animation = new GifSprite({\n     *     source,\n     *     fps: 24 // Use 24 FPS if GIF timing is missing\n     * });\n     * ```\n     * @see {@link GifSprite.play}\n     * @see {@link GifSprite.stop}\n     * @see {@link GifSprite.update}\n     */\n    fps?: number;\n}\n\n/**\n * Runtime object for playing animated GIFs with advanced playback control.\n *\n * Features:\n * - Play, pause, and seek controls\n * - Adjustable animation speed\n * - Loop control\n * - Frame change callbacks\n * - Auto-updating via shared ticker\n *\n * This class extends Sprite and provides similar functionality to AnimatedSprite,\n * but specifically optimized for GIF playback.\n * @example\n * ```ts\n * import { GifSprite, Assets } from 'pixi.js';\n *\n * // Load and create a GIF sprite\n * const source = await Assets.load('animation.gif');\n * const animation = new GifSprite({\n *     source,\n *     animationSpeed: 1,\n *     loop: true,\n *     autoPlay: true\n * });\n *\n * // Add to stage\n * app.stage.addChild(animation);\n *\n * // Control playback\n * animation.play();\n * animation.stop();\n * animation.currentFrame = 5; // Jump to frame\n * ```\n * @category gif\n * @see Thanks to {@link https://github.com/matt-way/gifuct-js/ gifuct-js}\n * @standard\n */\nclass GifSprite extends Sprite\n{\n    /**\n     * Default configuration options for GifSprite instances.\n     *\n     * These values are used when specific options are not provided to the constructor.\n     * Each property can be overridden by passing it in the options object.\n     * @example\n     * ```ts\n     * GifSprite.defaultOptions.fps = 24; // Change default FPS to 24\n     * GifSprite.defaultOptions.loop = false; // Disable looping by default\n     *\n     * const animation = new GifSprite(); // Will use these defaults\n     * ```\n     */\n    public static defaultOptions: Omit<GifSpriteOptions, 'source'> = {\n        fps: 30,\n        loop: true,\n        animationSpeed: 1,\n        autoPlay: true,\n        autoUpdate: true,\n        onComplete: null,\n        onFrameChange: null,\n        onLoop: null,\n    };\n\n    /**\n     * Animation playback speed multiplier.\n     * Higher values speed up the animation, lower values slow it down.\n     * @default 1\n     * @example\n     * ```ts\n     * const animation = new GifSprite({ source });\n     * animation.animationSpeed = 2; // 2x speed\n     * ```\n     * @see {@link GifSprite.play}\n     * @see {@link GifSprite.stop}\n     */\n    public animationSpeed = 1;\n\n    /**\n     * Whether to loop the animation.\n     * If `false`, the animation will stop after the last frame.\n     * @default true\n     * @example\n     * ```ts\n     * const animation = new GifSprite({ source, loop: false });\n     * ```\n     */\n    public loop = true;\n\n    /**\n     * Callback when non-looping animation completes.\n     * This is only called if `loop` is set to `false`.\n     * If `loop` is `true`, use {@link GifSprite.onLoop} instead.\n     * @default null\n     * @example\n     * ```ts\n     * const animation = new GifSprite({\n     *     source,\n     *     onComplete: () => {\n     *         console.log('Animation finished!');\n     *     }\n     * });\n     * ```\n     * @see {@link GifSprite.play}\n     * @see {@link GifSprite.stop}\n     */\n    public onComplete?: () => void;\n\n    /**\n     * Callback when animation frame changes.\n     * This is called every time the current frame changes,\n     * allowing you to respond to frame changes in real-time.\n     * @default null\n     * @example\n     * ```ts\n     * const animation = new GifSprite({\n     *     source,\n     *     onFrameChange: (currentFrame) => {\n     *         console.log(`Current frame: ${currentFrame}`);\n     *     }\n     * });\n     * ```\n     * @see {@link GifSprite.currentFrame}\n     * @see {@link GifSprite.play}\n     * @see {@link GifSprite.stop}\n     */\n    public onFrameChange?: (currentFrame: number) => void;\n\n    /**\n     * Callback when looping animation completes a loop.\n     * If `loop` is `false`, this will not be called.\n     * @default null\n     * @example\n     * ```ts\n     * const animation = new GifSprite({\n     *     source,\n     *     onLoop: () => {\n     *         console.log('Animation looped!');\n     *     }\n     * });\n     * ```\n     * @see {@link GifSprite.play}\n     * @see {@link GifSprite.stop}\n     */\n    public onLoop?: () => void;\n\n    /**\n     * The total duration of animation in milliseconds.\n     * This represents the length of one complete animation cycle.\n     * @example\n     * ```ts\n     * // Get animation duration\n     * const animation = new GifSprite({ source });\n     * console.log('Duration:', animation.duration); // e.g. 1000 for 1 second\n     * ```\n     * @readonly\n     * @default 0\n     * @remarks\n     * - Set during initialization from last frame's end time\n     * - Used for progress calculation and loop timing\n     * - Value is in milliseconds\n     * - Cannot be modified after creation\n     * @see {@link GifSprite.progress} For animation progress\n     * @see {@link GifSprite.currentFrame} For current frame number\n     */\n    public readonly duration: number = 0;\n\n    /**\n     * Whether to start playing right away when created.\n     * If `false`, you must call {@link GifSprite.play} to start playback.\n     * @default true\n     * @example\n     * ```ts\n     * const animation = new GifSprite({ source, autoPlay: true });\n     * ```\n     * @see {@link GifSprite.play}\n     */\n    public readonly autoPlay: boolean = true;\n\n    /** Collection of frame to render. */\n    private _source: GifSource;\n\n    /**\n     * Dirty means the image needs to be redrawn. Set to `true` to force redraw.\n     * @advanced\n     */\n    public dirty = false;\n\n    /** The current frame number (zero-based index). */\n    private _currentFrame = 0;\n\n    /** `true` uses {@link Ticker.shared} to auto update animation time.*/\n    private _autoUpdate = false;\n\n    /** `true` if the instance is currently connected to {@link Ticker.shared} to auto update animation time. */\n    private _isConnectedToTicker = false;\n\n    /** If animation is currently playing. */\n    private _playing = false;\n\n    /** Current playback position in milliseconds. */\n    private _currentTime = 0;\n\n    /**\n     * @param source - Source, default options will be used.\n     */\n    constructor(source: GifSource);\n\n    /**\n     * @param options - Options for the GifSprite\n     */\n    constructor(options: GifSpriteOptions);\n\n    constructor(...args: [GifSource] | [GifSpriteOptions])\n    {\n        const options = args[0] instanceof GifSource ? { source: args[0] } : args[0];\n\n        // Get the options, apply defaults\n        const {\n            source,\n            fps,\n            loop,\n            animationSpeed,\n            autoPlay,\n            autoUpdate,\n            onComplete,\n            onFrameChange,\n            onLoop,\n            ...rest\n        } = Object.assign({},\n            GifSprite.defaultOptions,\n            options\n        );\n\n        super({ texture: Texture.EMPTY, ...rest });\n\n        // Handle rerenders\n        this.onRender = () => this._updateFrame();\n\n        this.texture = source.textures[0];\n\n        this.duration = source.frames[source.frames.length - 1].end;\n        this._source = source;\n        this._playing = false;\n        this._currentTime = 0;\n        this._isConnectedToTicker = false;\n        Object.assign(this, {\n            fps,\n            loop,\n            animationSpeed,\n            autoPlay,\n            autoUpdate,\n            onComplete,\n            onFrameChange,\n            onLoop,\n        });\n\n        // Draw the first frame\n        this.currentFrame = 0;\n        if (autoPlay)\n        {\n            this.play();\n        }\n    }\n\n    /**\n     * Stops the animation playback.\n     * Halts at the current frame and disconnects from the ticker if auto-updating.\n     * @example\n     * ```ts\n     * // Basic stop\n     * const animation = new GifSprite({ source });\n     * animation.stop();\n     *\n     * // Stop at specific frame\n     * animation.currentFrame = 5;\n     * animation.stop();\n     *\n     * // Stop and reset\n     * animation.currentFrame = 0;\n     * animation.stop();\n     * ```\n     * @remarks\n     * - Does nothing if animation is already stopped\n     * - Maintains current frame position\n     * - Disconnects from shared ticker if auto-updating\n     * - Can be resumed with play()\n     * @see {@link GifSprite.play} For resuming playback\n     * @see {@link GifSprite.currentFrame} For frame control\n     */\n    public stop(): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        this._playing = false;\n        if (this._autoUpdate && this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /**\n     * Starts or resumes animation playback.\n     * If animation is at the last frame and not looping, playback will restart from the beginning.\n     * @example\n     * ```ts\n     * // Basic playback\n     * const animation = new GifSprite({ source, autoPlay: false });\n     * animation.play();\n     *\n     * // Play after stopping\n     * animation.stop();\n     * animation.play(); // Resumes from current frame\n     *\n     * // Play with auto-updating disabled\n     * const animation = new GifSprite({\n     *     source,\n     *     autoPlay: false,\n     *     autoUpdate: false\n     * });\n     * animation.play();\n     * app.ticker.add((ticker) => {\n     *     animation.update(ticker);\n     * });\n     * ```\n     * @remarks\n     * - Does nothing if animation is already playing\n     * - Connects to shared ticker if autoUpdate is true\n     * - Restarts from beginning if at last frame of non-looping animation\n     * - Maintains current frame position otherwise\n     * @see {@link GifSprite.stop} For stopping playback\n     * @see {@link GifSprite.playing} For checking playback status\n     * @see {@link GifSprite.autoUpdate} For controlling automatic updates\n     */\n    public play(): void\n    {\n        if (this._playing)\n        {\n            return;\n        }\n\n        this._playing = true;\n        if (this._autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isConnectedToTicker = true;\n        }\n\n        // If we're on the last frame and stopped, play should resume from beginning\n        if (!this.loop && this.currentFrame === this._source.frames.length - 1)\n        {\n            this._currentTime = 0;\n        }\n    }\n\n    /**\n     * Gets the current progress of the animation as a value between 0 and 1.\n     * Useful for tracking animation completion and implementing progress bars.\n     * @example\n     * ```ts\n     * // Basic progress tracking\n     * const animation = new GifSprite({ source });\n     * console.log('Progress:', Math.round(animation.progress * 100) + '%');\n     *\n     * // Update progress bar\n     * app.ticker.add(() => {\n     *     progressBar.width = animation.progress * 200; // 200px total width\n     * });\n     *\n     * // Check if animation is near end\n     * if (animation.progress > 0.9) {\n     *     console.log('Animation almost complete!');\n     * }\n     * ```\n     * @remarks\n     * - Returns 0 at start\n     * - Returns 1 when complete\n     * - Updates continuously during playback\n     * - Based on currentTime and total duration\n     * @readonly\n     * @see {@link GifSprite.duration} For total animation length\n     */\n    public get progress(): number\n    {\n        return this._currentTime / this.duration;\n    }\n\n    /** `true` if the current animation is playing */\n    public get playing(): boolean\n    {\n        return this._playing;\n    }\n\n    /**\n     * Updates the object transform for rendering.\n     * This method is called automatically by the ticker if `autoUpdate` is enabled.\n     * Only updates if the animation is currently playing.\n     * > [!IMPORTANT] Call this manually when `autoUpdate` is set to `false` to control animation timing.\n     * @param ticker - Ticker instance used to calculate frame timing\n     * @example\n     * ```ts\n     * // Manual update with app ticker\n     * const animation = new GifSprite({\n     *     source,\n     *     autoUpdate: false\n     * });\n     *\n     * // Add to custom ticker\n     * app.ticker.add(() => {\n     *     animation.update(app.ticker);\n     * });\n     *\n     * // Update with custom timing\n     * const customTicker = new Ticker();\n     * customTicker.add(() => {\n     *     animation.update(customTicker);\n     * });\n     * ```\n     * @see {@link GifSprite.autoUpdate} For automatic update control\n     * @see {@link GifSprite.playing} For playback state\n     * @see {@link Ticker} For timing system details\n     */\n    public update(ticker: Ticker): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        const elapsed = this.animationSpeed * ticker.deltaTime / Ticker.targetFPMS;\n        const currentTime = this._currentTime + elapsed;\n        const localTime = currentTime % this.duration;\n\n        const localFrame = this._source.frames.findIndex((frame) =>\n            frame.start <= localTime && frame.end > localTime);\n\n        if (currentTime >= this.duration)\n        {\n            if (this.loop)\n            {\n                this._currentTime = localTime;\n                this._updateFrameIndex(localFrame);\n                this.onLoop?.();\n            }\n            else\n            {\n                this._currentTime = this.duration;\n                this._updateFrameIndex(this.totalFrames - 1);\n                this.onComplete?.();\n                this.stop();\n            }\n        }\n        else\n        {\n            this._currentTime = localTime;\n            this._updateFrameIndex(localFrame);\n        }\n    }\n\n    /** Redraw the current frame, is necessary for the animation to work when */\n    private _updateFrame(): void\n    {\n        if (!this.dirty)\n        {\n            return;\n        }\n\n        // Update the current frame\n        this.texture = this._source.frames[this._currentFrame].texture;\n\n        // Mark as clean\n        this.dirty = false;\n    }\n\n    /**\n     * Whether to use {@link Ticker.shared} to auto update animation time.\n     * Controls if the animation updates automatically using the shared ticker.\n     * @example\n     * ```ts\n     * // Using auto-update (default)\n     * const animation = new GifSprite({\n     *     source,\n     *     autoUpdate: true\n     * });\n     *\n     * // Manual updates\n     * const animation = new GifSprite({\n     *     source,\n     *     autoUpdate: false\n     * });\n     *\n     * // Custom update loop\n     * app.ticker.add(() => {\n     *     animation.update(app.ticker);\n     * });\n     *\n     * // Switch update modes at runtime\n     * animation.autoUpdate = false; // Disconnect from shared ticker\n     * animation.autoUpdate = true;  // Reconnect if playing\n     * ```\n     * @default true\n     * @see {@link GifSprite.update} For manual updating\n     * @see {@link Ticker.shared} For the shared ticker instance\n     */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._playing)\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n\n    /**\n     * Gets or sets the current frame number.\n     * Controls which frame of the GIF animation is currently displayed.\n     * @example\n     * ```ts\n     * // Get current frame\n     * const animation = new GifSprite({ source });\n     * console.log('Current frame:', animation.currentFrame);\n     *\n     * // Jump to specific frame\n     * animation.currentFrame = 5;\n     *\n     * // Reset to first frame\n     * animation.currentFrame = 0;\n     *\n     * // Get frame at specific progress\n     * const frameAtProgress = Math.floor(animation.totalFrames * 0.5); // 50%\n     * animation.currentFrame = frameAtProgress;\n     * ```\n     * @throws {Error} If frame index is out of range\n     * @remarks\n     * - Zero-based index (0 to totalFrames-1)\n     * - Updates animation time to frame start\n     * - Triggers frame change callback\n     * - Marks sprite as dirty for redraw\n     * @see {@link GifSprite.totalFrames} For frame count\n     * @see {@link GifSprite.onFrameChange} For frame change events\n     */\n    get currentFrame(): number\n    {\n        return this._currentFrame;\n    }\n    set currentFrame(value: number)\n    {\n        this._updateFrameIndex(value);\n        this._currentTime = this._source.frames[value].start;\n    }\n\n    /**\n     * The source GIF data containing frame textures and timing information.\n     * This represents the underlying animation data used by the sprite.\n     * @example\n     * ```ts\n     * // Access source data\n     * const animation = new GifSprite({ source });\n     * const frameCount = animation.source.totalFrames;\n     * const frameTexture = animation.source.textures[0];\n     *\n     * // Share source between sprites\n     * const clone = new GifSprite({\n     *     source: animation.source,\n     *     autoPlay: false\n     * });\n     *\n     * // Check source properties\n     * console.log('Total frames:', animation.source.totalFrames);\n     * console.log('Frame timing:', animation.source.frames);\n     * ```\n     * @remarks\n     * - Contains all frame textures\n     * - Manages frame timing data\n     * - Can be shared between sprites\n     * - Destroyed with sprite if destroyData=true\n     * @readonly\n     * @see {@link GifSource} For source data implementation\n     * @see {@link GifSprite.clone} For creating independent instances\n     */\n    get source(): GifSource\n    {\n        return this._source;\n    }\n\n    /**\n     * Internally handle updating the frame index\n     * @param value\n     */\n    private _updateFrameIndex(value: number): void\n    {\n        if (value < 0 || value >= this.totalFrames)\n        {\n            throw new Error(`Frame index out of range, expecting 0 to ${this.totalFrames}, got ${value}`);\n        }\n        if (this._currentFrame !== value)\n        {\n            this._currentFrame = value;\n            this.dirty = true;\n            this.onFrameChange?.(value);\n        }\n    }\n\n    /**\n     * Gets the total number of frames in the GIF animation.\n     * @example\n     * ```ts\n     * // Get total frames\n     * const animation = new GifSprite({ source });\n     * console.log('Total frames:', animation.totalFrames);\n     * ```\n     * @readonly\n     * @see {@link GifSprite.currentFrame} For current frame index\n     * @see {@link GifSource.totalFrames} For source frame count\n     */\n    get totalFrames(): number\n    {\n        return this._source.totalFrames;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param destroyData - Destroy the data, cannot be used again.\n     * @example\n     * ```ts\n     * const animation = new GifSprite({ source });\n     * // Do something with animation...\n     * animation.destroy(true); // Destroy the animation and its source data\n     *\n     * // If you want to keep the source data for reuse, use:\n     * animation.destroy(false); // Destroy the animation but keep source data\n     * ```\n     */\n    public destroy(destroyData: boolean = false): void\n    {\n        this.stop();\n        super.destroy();\n\n        if (destroyData)\n        {\n            this._source.destroy();\n        }\n\n        const forceClear = null as any;\n\n        this._source = forceClear;\n        this.onComplete = forceClear;\n        this.onFrameChange = forceClear;\n        this.onLoop = forceClear;\n    }\n\n    /**\n     * Creates an independent copy of this GifSprite instance.\n     * Useful for creating multiple animations that share the same source data\n     * but can be controlled independently.\n     * > [!IMPORTANT]\n     * > The cloned sprite will have its own playback state, so you can play,\n     * > pause, or seek it without affecting the original sprite.\n     * @example\n     * ```ts\n     * // Create original animation\n     * const animation = new GifSprite({ source });\n     *\n     * // Create independent clone\n     * const clone = animation.clone();\n     * clone.play();  // Plays independently\n     * animation.stop(); // Original stops, clone continues\n     *\n     * // Clone with modified properties\n     * const halfSpeed = animation.clone();\n     * halfSpeed.animationSpeed = 0.5;\n     * ```\n     * @returns {GifSprite} A new GifSprite instance with the same properties\n     * @see {@link GifSprite.source} For shared source data\n     * @see {@link GifSprite.destroy} For cleanup\n     */\n    public clone(): GifSprite\n    {\n        const clone = new GifSprite({\n            source: this._source,\n            autoUpdate: this._autoUpdate,\n            loop: this.loop,\n            autoPlay: this.autoPlay,\n            animationSpeed: this.animationSpeed,\n            onComplete: this.onComplete,\n            onFrameChange: this.onFrameChange,\n            onLoop: this.onLoop,\n        });\n\n        clone.dirty = true;\n\n        return clone;\n    }\n}\n\nexport { GifSprite };\nexport type { GifSpriteOptions };\n","import { extensions } from '../extensions/Extensions';\nimport { GifAsset } from './GifAsset';\n\nexport * from './index';\n\nextensions.add(GifAsset);\n"],"names":["lib","loop_1","conditional_1","parse_1","parse","stream","schema","result","parent","partSchema","key","conditional","conditionFunc","loop","continueFunc","arr","lastStreamPos","newParent","uint8","readBits_1","readArray_1","readUnsigned_1","readString_1","peekBytes_1","readBytes_1","peekByte_1","readByte_1","buildStream_1","buildStream","uint8Data","readByte","peekByte","offset","readBytes","length","peekBytes","readString","value","readUnsigned","littleEndian","bytes","readArray","byteSize","totalOrFunc","total","parser","i","subBitsTotal","bits","startIndex","readBits","_byte","res","def","exports","_","require$$0","_uint","require$$1","subBlocksSchema","terminator","chunks","streamSize","size","availableSize","gceSchema","codes","imageSchema","textSchema","applicationSchema","commentSchema","nextCode","_default","deinterlace_1","deinterlace_2","deinterlace","pixels","width","newPixels","rows","cpRow","toRow","fromRow","fromPixels","offsets","steps","pass","lzw_1","lzw_2","lzw","minCodeSize","data","pixelCount","MAX_STACK_SIZE","nullCode","npix","available","clear","code_mask","code_size","end_of_information","in_code","old_code","code","datum","data_size","first","top","bi","pi","dstPixels","prefix","suffix","pixelStack","count","decompressFrames_1","decompressFrame_1","parseGIF_1","_gif","_interopRequireDefault","_jsBinarySchemaParser","require$$2","_deinterlace","require$$3","_lzw","require$$4","obj","parseGIF","arrayBuffer","byteData","generatePatch","image","totalPixels","patchData","pos","colorIndex","color","decompressFrame","frame","gct","buildImagePatch","resultImage","decompressFrames","parsedGif","buildImagePatches","f","j","T","B","S","a","e","t","A","R","r","C","u","m","s","o","W","F","q","b","h","l","d","DOMAdapter","Texture","CanvasSource","ExtensionType","path","x","Sprite","Ticker","UPDATE_PRIORITY","extensions"],"mappings":";;;;;;u9BAEA,OAAO,eAAeA,EAAS,aAAc,CAC3C,MAAO,EACT,CAAC,EACD,IAAAC,GAAAD,EAAA,KAAeE,GAAmBF,EAAA,YAAGG,WAAgB,OAEjDC,GAAQ,SAASA,EAAMC,EAAQC,EAAQ,CACzC,IAAIC,EAAS,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAY,UAAU,CAAC,EAAI,CAAA,EAC7EC,EAAS,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAY,UAAU,CAAC,EAAID,EAEjF,GAAI,MAAM,QAAQD,CAAM,EACtBA,EAAO,QAAQ,SAAUG,EAAY,CACnC,OAAOL,EAAMC,EAAQI,EAAYF,EAAQC,CAAM,CACrD,CAAK,UACQ,OAAOF,GAAW,WAC3BA,EAAOD,EAAQE,EAAQC,EAAQJ,CAAK,MAC/B,CACL,IAAIM,EAAM,OAAO,KAAKJ,CAAM,EAAE,CAAC,EAE3B,MAAM,QAAQA,EAAOI,CAAG,CAAC,GAC3BF,EAAOE,CAAG,EAAI,GACdN,EAAMC,EAAQC,EAAOI,CAAG,EAAGH,EAAQC,EAAOE,CAAG,CAAC,GAE9CF,EAAOE,CAAG,EAAIJ,EAAOI,CAAG,EAAEL,EAAQE,EAAQC,EAAQJ,CAAK,CAE1D,CAED,OAAOG,CACT,EAEaJ,GAAAH,EAAA,MAAGI,GAEZO,GAAc,SAAqBL,EAAQM,EAAe,CAC5D,OAAO,SAAUP,EAAQE,EAAQC,EAAQJ,EAAO,CAC1CQ,EAAcP,EAAQE,EAAQC,CAAM,GACtCJ,EAAMC,EAAQC,EAAQC,EAAQC,CAAM,CAE1C,CACA,EAEmBN,GAAAF,EAAA,YAAGW,GAElBE,GAAO,SAAcP,EAAQQ,EAAc,CAC7C,OAAO,SAAUT,EAAQE,EAAQC,EAAQJ,EAAO,CAI9C,QAHIW,EAAM,CAAA,EACNC,EAAgBX,EAAO,IAEpBS,EAAaT,EAAQE,EAAQC,CAAM,GAAG,CAC3C,IAAIS,EAAY,CAAA,EAIhB,GAHAb,EAAMC,EAAQC,EAAQC,EAAQU,CAAS,EAGnCZ,EAAO,MAAQW,EACjB,MAGFA,EAAgBX,EAAO,IACvBU,EAAI,KAAKE,CAAS,CACnB,CAED,OAAOF,CACX,CACA,EAEAd,GAAAD,EAAA,KAAea,YC/Df,OAAO,eAAeK,EAAS,aAAc,CAC3C,MAAO,EACT,CAAC,EACD,IAAAC,GAAAD,EAAA,SAAmBE,GAAiBF,EAAA,UAAGG,kBAAuBC,GAAAJ,EAAA,WAAqBK,GAAiBL,EAAA,UAAGM,eAAoBC,GAAAP,EAAA,SAAmBQ,GAAgBR,EAAA,SAAGS,iBAAsB,OAGnLC,GAAc,SAAqBC,EAAW,CAChD,MAAO,CACL,KAAMA,EACN,IAAK,CACT,CACA,EAEmBF,GAAAT,EAAA,YAAGU,GAElBE,EAAW,UAAoB,CACjC,OAAO,SAAUzB,EAAQ,CACvB,OAAOA,EAAO,KAAKA,EAAO,KAAK,CACnC,CACA,EAEgBqB,GAAAR,EAAA,SAAGY,EAEfC,GAAW,UAAoB,CACjC,IAAIC,EAAS,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,OAAY,UAAU,CAAC,EAAI,EACjF,OAAO,SAAU3B,EAAQ,CACvB,OAAOA,EAAO,KAAKA,EAAO,IAAM2B,CAAM,CAC1C,CACA,EAEgBP,GAAAP,EAAA,SAAGa,GAEfE,EAAY,SAAmBC,EAAQ,CACzC,OAAO,SAAU7B,EAAQ,CACvB,OAAOA,EAAO,KAAK,SAASA,EAAO,IAAKA,EAAO,KAAO6B,CAAM,CAChE,CACA,EAEiBV,GAAAN,EAAA,UAAGe,EAEhBE,GAAY,SAAmBD,EAAQ,CACzC,OAAO,SAAU7B,EAAQ,CACvB,OAAOA,EAAO,KAAK,SAASA,EAAO,IAAKA,EAAO,IAAM6B,CAAM,CAC/D,CACA,EAEiBX,GAAAL,EAAA,UAAGiB,GAEhBC,GAAa,SAAoBF,EAAQ,CAC3C,OAAO,SAAU7B,EAAQ,CACvB,OAAO,MAAM,KAAK4B,EAAUC,CAAM,EAAE7B,CAAM,CAAC,EAAE,IAAI,SAAUgC,EAAO,CAChE,OAAO,OAAO,aAAaA,CAAK,CACtC,CAAK,EAAE,KAAK,EAAE,CACd,CACA,EAEkBf,GAAAJ,EAAA,WAAGkB,GAEjBE,GAAe,SAAsBC,EAAc,CACrD,OAAO,SAAUlC,EAAQ,CACvB,IAAImC,EAAQP,EAAU,CAAC,EAAE5B,CAAM,EAC/B,OAAOkC,GAAgBC,EAAM,CAAC,GAAK,GAAKA,EAAM,CAAC,GAAKA,EAAM,CAAC,GAAK,GAAKA,EAAM,CAAC,CAChF,CACA,EAEoBnB,GAAAH,EAAA,aAAGoB,GAEnBG,GAAY,SAAmBC,EAAUC,EAAa,CACxD,OAAO,SAAUtC,EAAQE,EAAQC,EAAQ,CAKvC,QAJIoC,EAAQ,OAAOD,GAAgB,WAAaA,EAAYtC,EAAQE,EAAQC,CAAM,EAAImC,EAClFE,EAASZ,EAAUS,CAAQ,EAC3B3B,EAAM,IAAI,MAAM6B,CAAK,EAEhBE,EAAI,EAAGA,EAAIF,EAAOE,IACzB/B,EAAI+B,CAAC,EAAID,EAAOxC,CAAM,EAGxB,OAAOU,CACX,CACA,EAEiBK,GAAAF,EAAA,UAAGuB,GAEhBM,GAAe,SAAsBC,EAAMC,EAAYf,EAAQ,CAGjE,QAFI3B,EAAS,EAEJuC,EAAI,EAAGA,EAAIZ,EAAQY,IAC1BvC,GAAUyC,EAAKC,EAAaH,CAAC,GAAK,KAAK,IAAI,EAAGZ,EAASY,EAAI,CAAC,EAG9D,OAAOvC,CACT,EAEI2C,GAAW,SAAkB5C,EAAQ,CACvC,OAAO,SAAUD,EAAQ,CAMvB,QALI8C,EAAQrB,IAAWzB,CAAM,EAGzB2C,EAAO,IAAI,MAAM,CAAC,EAEbF,EAAI,EAAGA,EAAI,EAAGA,IACrBE,EAAK,EAAIF,CAAC,EAAI,CAAC,EAAEK,EAAQ,GAAKL,GAIhC,OAAO,OAAO,KAAKxC,CAAM,EAAE,OAAO,SAAU8C,EAAK1C,EAAK,CACpD,IAAI2C,EAAM/C,EAAOI,CAAG,EAEpB,OAAI2C,EAAI,OACND,EAAI1C,CAAG,EAAIqC,GAAaC,EAAMK,EAAI,MAAOA,EAAI,MAAM,EAEnDD,EAAI1C,CAAG,EAAIsC,EAAKK,EAAI,KAAK,EAGpBD,CACR,EAAE,CAAE,CAAA,CACT,CACA,EAEAjC,GAAAD,EAAA,SAAmBgC,eCzHnB,aAEA,OAAO,eAAwBI,EAAA,aAAc,CAC3C,MAAO,EACT,CAAC,EACDA,EAAQ,QAAa,OAErB,IAAIC,EAAIC,EAEJC,EAAQC,EAGRC,EAAkB,CACpB,OAAQ,SAAgBtD,EAAQ,CAM9B,QALIuD,EAAa,EACbC,EAAS,CAAA,EACTC,EAAazD,EAAO,KAAK,OACzBuC,EAAQ,EAEHmB,KAAWN,EAAM,UAAW,EAACpD,CAAM,EAAG0D,IAASH,GAGjDG,EAH6DA,KAAWN,EAAM,UAAQ,EAAIpD,CAAM,EAAG,CAKxG,GAAIA,EAAO,IAAM0D,GAAQD,EAAY,CACnC,IAAIE,EAAgBF,EAAazD,EAAO,IACxCwD,EAAO,QAASJ,EAAM,WAAWO,CAAa,EAAE3D,CAAM,CAAC,EACvDuC,GAASoB,EACT,KACD,CAEDH,EAAO,QAASJ,EAAM,WAAWM,CAAI,EAAE1D,CAAM,CAAC,EAC9CuC,GAASmB,CACV,CAKD,QAHIxD,EAAS,IAAI,WAAWqC,CAAK,EAC7BZ,EAAS,EAEJc,EAAI,EAAGA,EAAIe,EAAO,OAAQf,IACjCvC,EAAO,IAAIsD,EAAOf,CAAC,EAAGd,CAAM,EAC5BA,GAAU6B,EAAOf,CAAC,EAAE,OAGtB,OAAOvC,CACR,CACH,EAEI0D,KAAgBV,EAAE,aAAa,CACjC,IAAK,CAAC,CACJ,SAAWE,EAAM,WAAW,CAAC,CACjC,EAAK,CACD,YAAcA,EAAM,UAAW,CACnC,EAAK,CACD,UAAYA,EAAM,UAAU,CAC1B,OAAQ,CACN,MAAO,EACP,OAAQ,CACT,EACD,SAAU,CACR,MAAO,EACP,OAAQ,CACT,EACD,UAAW,CACT,MAAO,CACR,EACD,sBAAuB,CACrB,MAAO,CACR,CACP,CAAK,CACL,EAAK,CACD,SAAWA,EAAM,cAAc,EAAI,CACvC,EAAK,CACD,yBAA2BA,EAAM,UAAW,CAChD,EAAK,CACD,cAAgBA,EAAM,UAAW,CACrC,CAAG,CACF,EAAE,SAAUpD,EAAQ,CACnB,IAAI6D,KAAYT,EAAM,WAAW,CAAC,EAAEpD,CAAM,EAC1C,OAAO6D,EAAM,CAAC,IAAM,IAAQA,EAAM,CAAC,IAAM,GAC3C,CAAC,EAEGC,KAAkBZ,EAAE,aAAa,CACnC,MAAO,CAAC,CACN,QAAUE,EAAM,UAAW,CAC/B,EAAK,CACD,WAAY,CAAC,CACX,QAAUA,EAAM,cAAc,EAAI,CACxC,EAAO,CACD,OAASA,EAAM,cAAc,EAAI,CACvC,EAAO,CACD,SAAWA,EAAM,cAAc,EAAI,CACzC,EAAO,CACD,UAAYA,EAAM,cAAc,EAAI,CAC1C,EAAO,CACD,OAASA,EAAM,UAAU,CACvB,OAAQ,CACN,MAAO,CACR,EACD,WAAY,CACV,MAAO,CACR,EACD,KAAM,CACJ,MAAO,CACR,EACD,OAAQ,CACN,MAAO,EACP,OAAQ,CACT,EACD,KAAM,CACJ,MAAO,EACP,OAAQ,CACT,CACT,CAAO,CACP,CAAK,CACL,KAASF,EAAE,aAAa,CACpB,OAASE,EAAM,WAAW,EAAG,SAAUpD,EAAQE,EAAQC,EAAQ,CAC7D,OAAO,KAAK,IAAI,EAAGA,EAAO,WAAW,IAAI,KAAO,CAAC,CACvD,CAAK,CACL,EAAK,SAAUH,EAAQE,EAAQC,EAAQ,CACnC,OAAOA,EAAO,WAAW,IAAI,MACjC,CAAG,EAAG,CACF,KAAM,CAAC,CACL,eAAiBiD,EAAM,UAAW,CACnC,EAAEE,CAAe,CACtB,CAAG,CACF,EAAE,SAAUtD,EAAQ,CACnB,SAAWoD,EAAM,UAAQ,EAAIpD,CAAM,IAAM,EAC3C,CAAC,EAEG+D,KAAiBb,EAAE,aAAa,CAClC,KAAM,CAAC,CACL,SAAWE,EAAM,WAAW,CAAC,CACjC,EAAK,CACD,aAAeA,EAAM,UAAW,CACpC,EAAK,CACD,QAAS,SAAiBpD,EAAQE,EAAQC,EAAQ,CAChD,SAAWiD,EAAM,WAAWjD,EAAO,KAAK,SAAS,EAAEH,CAAM,CAC1D,CACF,EAAEsD,CAAe,CACnB,EAAE,SAAUtD,EAAQ,CACnB,IAAI6D,KAAYT,EAAM,WAAW,CAAC,EAAEpD,CAAM,EAC1C,OAAO6D,EAAM,CAAC,IAAM,IAAQA,EAAM,CAAC,IAAM,CAC3C,CAAC,EAEGG,KAAwBd,EAAE,aAAa,CACzC,YAAa,CAAC,CACZ,SAAWE,EAAM,WAAW,CAAC,CACjC,EAAK,CACD,aAAeA,EAAM,UAAW,CACpC,EAAK,CACD,GAAI,SAAYpD,EAAQE,EAAQC,EAAQ,CACtC,SAAWiD,EAAM,YAAYjD,EAAO,SAAS,EAAEH,CAAM,CACtD,CACF,EAAEsD,CAAe,CACnB,EAAE,SAAUtD,EAAQ,CACnB,IAAI6D,KAAYT,EAAM,WAAW,CAAC,EAAEpD,CAAM,EAC1C,OAAO6D,EAAM,CAAC,IAAM,IAAQA,EAAM,CAAC,IAAM,GAC3C,CAAC,EAEGI,KAAoBf,EAAE,aAAa,CACrC,QAAS,CAAC,CACR,SAAWE,EAAM,WAAW,CAAC,CAC9B,EAAEE,CAAe,CACnB,EAAE,SAAUtD,EAAQ,CACnB,IAAI6D,KAAYT,EAAM,WAAW,CAAC,EAAEpD,CAAM,EAC1C,OAAO6D,EAAM,CAAC,IAAM,IAAQA,EAAM,CAAC,IAAM,GAC3C,CAAC,EACG5D,EAAS,CAAC,CACZ,OAAQ,CAAC,CACP,aAAemD,EAAM,YAAY,CAAC,CACtC,EAAK,CACD,WAAaA,EAAM,YAAY,CAAC,CACpC,CAAG,CACH,EAAG,CACD,IAAK,CAAC,CACJ,SAAWA,EAAM,cAAc,EAAI,CACvC,EAAK,CACD,UAAYA,EAAM,cAAc,EAAI,CACxC,EAAK,CACD,OAASA,EAAM,UAAU,CACvB,OAAQ,CACN,MAAO,CACR,EACD,WAAY,CACV,MAAO,EACP,OAAQ,CACT,EACD,KAAM,CACJ,MAAO,CACR,EACD,KAAM,CACJ,MAAO,EACP,OAAQ,CACT,CACP,CAAK,CACL,EAAK,CACD,wBAA0BA,EAAM,UAAW,CAC/C,EAAK,CACD,oBAAsBA,EAAM,UAAW,CAC3C,CAAG,CACH,KAAOF,EAAE,aAAa,CACpB,OAASE,EAAM,WAAW,EAAG,SAAUpD,EAAQE,EAAQ,CACrD,OAAO,KAAK,IAAI,EAAGA,EAAO,IAAI,IAAI,KAAO,CAAC,CAC9C,CAAG,CACH,EAAG,SAAUF,EAAQE,EAAQ,CAC3B,OAAOA,EAAO,IAAI,IAAI,MACxB,CAAC,EACD,CACE,UAAYgD,EAAE,MAAM,CAACU,EAAWI,EAAmBC,EAAeH,EAAaC,CAAU,EAAG,SAAU/D,EAAQ,CAC5G,IAAIkE,KAAed,EAAM,UAAQ,EAAIpD,CAAM,EAK3C,OAAOkE,IAAa,IAAQA,IAAa,EAC7C,CAAG,CACH,CAAC,EACGC,EAAWlE,EACfgD,EAAQ,QAAakB,wBCxNrB,OAAO,eAAeC,EAAS,aAAc,CAC3C,MAAO,EACT,CAAC,EACD,IAAmBC,GAAAD,EAAA,YAAG,OAKlBE,GAAc,SAAqBC,EAAQC,EAAO,CAcpD,QAbIC,EAAY,IAAI,MAAMF,EAAO,MAAM,EACnCG,EAAOH,EAAO,OAASC,EAEvBG,EAAQ,SAAeC,EAAOC,EAAS,CACzC,IAAIC,EAAaP,EAAO,MAAMM,EAAUL,GAAQK,EAAU,GAAKL,CAAK,EACpEC,EAAU,OAAO,MAAMA,EAAW,CAACG,EAAQJ,EAAOA,CAAK,EAAE,OAAOM,CAAU,CAAC,CAC/E,EAGMC,EAAU,CAAC,EAAG,EAAG,EAAG,CAAC,EACrBC,EAAQ,CAAC,EAAG,EAAG,EAAG,CAAC,EACnBH,EAAU,EAELI,EAAO,EAAGA,EAAO,EAAGA,IAC3B,QAASL,EAAQG,EAAQE,CAAI,EAAGL,EAAQF,EAAME,GAASI,EAAMC,CAAI,EAC/DN,EAAMC,EAAOC,CAAO,EACpBA,IAIJ,OAAOJ,CACT,EAEAJ,GAAAD,EAAA,YAAsBE,YChCtB,OAAO,eAAeY,EAAS,aAAc,CAC3C,MAAO,EACT,CAAC,EACD,IAAWC,GAAAD,EAAA,IAAG,OAMVE,GAAM,SAAaC,EAAaC,EAAMC,EAAY,CACpD,IAAIC,EAAiB,KACjBC,EAAW,GACXC,EAAOH,EACPI,EAAWC,EAAOC,EAAWC,EAAWC,EAAoBC,EAASC,EAAUtD,EAAMuD,EAAMzD,EAAG0D,EAAOC,EAAWC,EAAOC,EAAKC,EAAIC,EAChIC,EAAY,IAAI,MAAMlB,CAAU,EAChCmB,EAAS,IAAI,MAAMlB,CAAc,EACjCmB,EAAS,IAAI,MAAMnB,CAAc,EACjCoB,EAAa,IAAI,MAAMpB,EAAiB,CAAC,EAU7C,IARAY,EAAYf,EACZO,EAAQ,GAAKQ,EACbL,EAAqBH,EAAQ,EAC7BD,EAAYC,EAAQ,EACpBK,EAAWR,EACXK,EAAYM,EAAY,EACxBP,GAAa,GAAKC,GAAa,EAE1BI,EAAO,EAAGA,EAAON,EAAOM,IAC3BQ,EAAOR,CAAI,EAAI,EACfS,EAAOT,CAAI,EAAIA,EAIjB,IAAIC,EAAOxD,EAAMkE,EAAOR,EAAOC,EAAKE,EAAID,EAGxC,IAFAJ,EAAQxD,EAAOkE,EAAQR,EAAQC,EAAME,EAAKD,EAAK,EAE1C9D,EAAI,EAAGA,EAAIiD,GAAO,CACrB,GAAIY,IAAQ,EAAG,CACb,GAAI3D,EAAOmD,EAAW,CAEpBK,GAASb,EAAKiB,CAAE,GAAK5D,EACrBA,GAAQ,EACR4D,IACA,QACD,CAOD,GAJAL,EAAOC,EAAQN,EACfM,IAAUL,EACVnD,GAAQmD,EAEJI,EAAOP,GAAaO,GAAQH,EAC9B,MAGF,GAAIG,GAAQN,EAAO,CAEjBE,EAAYM,EAAY,EACxBP,GAAa,GAAKC,GAAa,EAC/BH,EAAYC,EAAQ,EACpBK,EAAWR,EACX,QACD,CAED,GAAIQ,GAAYR,EAAU,CACxBmB,EAAWN,GAAK,EAAIK,EAAOT,CAAI,EAC/BD,EAAWC,EACXG,EAAQH,EACR,QACD,CASD,IAPAF,EAAUE,EAENA,GAAQP,IACViB,EAAWN,GAAK,EAAID,EACpBH,EAAOD,GAGFC,EAAON,GACZgB,EAAWN,GAAK,EAAIK,EAAOT,CAAI,EAC/BA,EAAOQ,EAAOR,CAAI,EAGpBG,EAAQM,EAAOT,CAAI,EAAI,IACvBU,EAAWN,GAAK,EAAID,EAIhBV,EAAYH,IACdkB,EAAOf,CAAS,EAAIM,EACpBU,EAAOhB,CAAS,EAAIU,EACpBV,IAEK,EAAAA,EAAYE,IAAoBF,EAAYH,IAC/CM,IACAD,GAAaF,IAIjBM,EAAWD,CACZ,CAGDM,IACAG,EAAUD,GAAI,EAAII,EAAWN,CAAG,EAChC7D,GACD,CAED,IAAKA,EAAI+D,EAAI/D,EAAIiD,EAAMjD,IACrBgE,EAAUhE,CAAC,EAAI,EAGjB,OAAOgE,CACT,EAEAtB,GAAAD,EAAA,IAAcE,GCnHd,OAAO,eAAezF,EAAS,aAAc,CAC3C,MAAO,EACT,CAAC,EACD,IAAAmH,EAAAnH,EAAA,iBAA2BoH,GAAuBpH,EAAA,gBAAGqH,aAAmB,OAEpEC,GAAOC,GAAuB/D,CAAkD,EAEhFgE,GAAwB9D,EAExBD,GAAQgE,EAERC,GAAeC,EAEfC,GAAOC,EAEX,SAASN,GAAuBO,EAAK,CAAE,OAAOA,GAAOA,EAAI,WAAaA,EAAM,CAAE,QAAWA,CAAG,CAAK,CAEjG,IAAIC,GAAW,SAAkBC,EAAa,CAC5C,IAAIC,EAAW,IAAI,WAAWD,CAAW,EACzC,SAAWR,GAAsB,UAAW/D,GAAM,aAAawE,CAAQ,EAAGX,GAAK,OAAU,CAC3F,EAEgBD,EAAArH,EAAA,SAAG+H,GAEfG,GAAgB,SAAuBC,EAAO,CAIhD,QAHIC,EAAcD,EAAM,OAAO,OAC3BE,EAAY,IAAI,kBAAkBD,EAAc,CAAC,EAE5CtF,EAAI,EAAGA,EAAIsF,EAAatF,IAAK,CACpC,IAAIwF,EAAMxF,EAAI,EACVyF,EAAaJ,EAAM,OAAOrF,CAAC,EAC3B0F,EAAQL,EAAM,WAAWI,CAAU,GAAK,CAAC,EAAG,EAAG,CAAC,EACpDF,EAAUC,CAAG,EAAIE,EAAM,CAAC,EACxBH,EAAUC,EAAM,CAAC,EAAIE,EAAM,CAAC,EAC5BH,EAAUC,EAAM,CAAC,EAAIE,EAAM,CAAC,EAC5BH,EAAUC,EAAM,CAAC,EAAIC,IAAeJ,EAAM,iBAAmB,IAAM,CACpE,CAED,OAAOE,CACT,EAEII,EAAkB,SAAyBC,EAAOC,EAAKC,EAAiB,CAC1E,GAAI,CAACF,EAAM,MAAO,CAChB,QAAQ,KAAK,2CAA2C,EACxD,MACD,CAED,IAAIP,EAAQO,EAAM,MAEdN,EAAcD,EAAM,WAAW,MAAQA,EAAM,WAAW,OAExDvD,KAAagD,GAAK,KAAKO,EAAM,KAAK,YAAaA,EAAM,KAAK,OAAQC,CAAW,EAE7ED,EAAM,WAAW,IAAI,aACvBvD,KAAa8C,GAAa,aAAa9C,EAAQuD,EAAM,WAAW,KAAK,GAGvE,IAAIU,EAAc,CAChB,OAAQjE,EACR,KAAM,CACJ,IAAK8D,EAAM,MAAM,WAAW,IAC5B,KAAMA,EAAM,MAAM,WAAW,KAC7B,MAAOA,EAAM,MAAM,WAAW,MAC9B,OAAQA,EAAM,MAAM,WAAW,MAChC,CACL,EAEE,OAAIP,EAAM,WAAW,KAAOA,EAAM,WAAW,IAAI,OAC/CU,EAAY,WAAaV,EAAM,IAE/BU,EAAY,WAAaF,EAIvBD,EAAM,MACRG,EAAY,OAASH,EAAM,IAAI,OAAS,IAAM,GAE9CG,EAAY,aAAeH,EAAM,IAAI,OAAO,SAExCA,EAAM,IAAI,OAAO,wBACnBG,EAAY,iBAAmBH,EAAM,IAAI,wBAKzCE,IACFC,EAAY,MAAQX,GAAcW,CAAW,GAGxCA,CACT,EAEuBzB,GAAApH,EAAA,gBAAGyI,EAEtBK,GAAmB,SAA0BC,EAAWC,EAAmB,CAC7E,OAAOD,EAAU,OAAO,OAAO,SAAUE,EAAG,CAC1C,OAAOA,EAAE,KACb,CAAG,EAAE,IAAI,SAAUA,EAAG,CAClB,OAAOR,EAAgBQ,EAAGF,EAAU,IAAKC,CAAiB,CAC9D,CAAG,CACH,EAEA7B,EAAAnH,EAAA,iBAA2B8I,GClE3B,IAAAI,GAAA,OAAA,eAAAD,EAAA,OAAA,sBAAAE,EAAA,OAAA,UAAA,eAAAC,EAAA,OAAA,UAAA,qBAAAC,EAAA,CAAAC,EAAAC,EAAAC,IAAAD,KAAAD,EAAAJ,GAAAI,EAAAC,EAAA,CAAA,WAAA,GAAA,aAAA,GAAA,SAAA,GAAA,MAAAC,CAAA,CAAA,EAAAF,EAAAC,CAAA,EAAAC,EAAAC,GAAA,CAAAH,EAAAC,IAAA,CAAA,QAAAC,KAAAD,IAAAA,EAAA,CAAA,GAAAJ,EAAA,KAAAI,EAAAC,CAAA,GAAAH,EAAAC,EAAAE,EAAAD,EAAAC,CAAA,CAAA,EAAA,GAAAP,EAAA,QAAAO,KAAAP,EAAAM,CAAA,EAAAH,EAAA,KAAAG,EAAAC,CAAA,GAAAH,EAAAC,EAAAE,EAAAD,EAAAC,CAAA,CAAA,EAAA,OAAAF,CAAA,EAAAI,GAAA,CAAAJ,EAAAC,IAAA,CAAA,IAAAC,EAAA,CAAA,EAAA,QAAAG,KAAAL,EAAAH,EAAA,KAAAG,EAAAK,CAAA,GAAAJ,EAAA,QAAAI,CAAA,EAAA,IAAAH,EAAAG,CAAA,EAAAL,EAAAK,CAAA,GAAA,GAAAL,GAAA,MAAAL,EAAA,QAAAU,KAAAV,EAAAK,CAAA,EAAAC,EAAA,QAAAI,CAAA,EAAA,GAAAP,EAAA,KAAAE,EAAAK,CAAA,IAAAH,EAAAG,CAAA,EAAAL,EAAAK,CAAA,GAAA,OAAAH,CAAA,EAAA,MAAAI,CAAA,CAAA,YAAAL,EAAA,CAAA,KAAA,CAAA,CAAA,QAAA,CAAA,MAAAC,EAAA,OAAAG,CAAA,CAAA,CAAA,EAAAJ,EAAA,KAAA,MAAAC,EAAA,KAAA,OAAAG,EAAA,KAAA,OAAAJ,EAAA,KAAA,SAAA,KAAA,OAAA,IAAA,GAAA,EAAA,OAAA,EAAA,KAAA,YAAA,KAAA,OAAA,OAAA,KAAA,SAAA,KAAA,OAAA,KAAA,YAAA,CAAA,EAAA,GAAA,CAAA,SAAA,CAAA,UAAAA,KAAA,KAAA,SAAAA,EAAA,QAAA,EAAA,EAAA,UAAAA,KAAA,KAAA,OAAAA,EAAA,QAAA,KAAA,KAAA,OAAA,OAAA,EAAA,KAAA,SAAA,OAAA,EAAA,OAAA,OAAA,KAAA,CAAA,OAAA,KAAA,SAAA,KAAA,MAAA,EAAA,OAAA,EAAA,SAAA,EAAA,YAAA,CAAA,CAAA,CAAA,CAAA,OAAA,KAAAA,EAAAC,EAAA,CAAA,GAAA,CAAAD,GAAAA,EAAA,aAAA,EAAA,MAAA,IAAA,MAAA,gBAAA,EAAA,MAAAI,EAAAE,GAAA,CAAA,IAAAC,EAAA,IAAAC,EAAA,KAAA,UAAAC,KAAAH,EAAA,OAAAE,GAAAD,EAAAE,EAAA,MAAA,KAAAF,EAAAC,EAAA,UAAAC,GAAA,EAAA,QAAAA,KAAAA,EAAA,IAAAD,EAAA,EAAA,EAAAE,EAAAV,CAAA,EAAAI,EAAA,CAAA,EAAA,MAAAO,EAAAC,EAAA,EAAA,EAAA,EAAAC,EAAA,CAAA,EAAAC,EAAA,EAAA,IAAA,MAAAC,EAAA,EAAA,IAAA,OAAAC,EA4GuBC,gBAEKA,IAAAA,EAAAA,aAAAA,EAAAA,CAAAA,EAAAA,EAAAA,EAAAA,WAAAA,KAAAA,CAAAA,mBAAAA,EAAAA,CAAAA,EAAAA,EAAAA,KAAAA,ifA+CCA,KAAAA,WAAAA,IAAAA,EAAAA,aAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA,WAAAA,IAAAA,EAAAA,aAAAA,EAAAA,EAAAA,CAAAA,EAAAA,EAAAA,KAAAA,CAAAA,MAAAA,EAAAA,IAAAA,EAAAA,EAAAA,QAAAA,IAWAC,KAAQ,QAAA,CAAA,OAAA,IACLC,KAAAA,aAAAA,GAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,GAAAA,CAAAA,CAAAA,OAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CChMjBC,MAAAA,EAAAA,CAAAA,UAAAA,KAAAA,cAUQC,MAAAA,UAAAA,CAAAA,KAAAA,SAAAA,GAAAA,IAAAA,MAAAA,GAAAA,CAAAA,GAAAA,EAAAA,KAAAA,EAAAA,OAAAA,MAAAA,GAAAA,EAAAA,OAAAA,GAAAA,IAAAA,KAAAA,CAAAA,EAAAA,OAAAA,CAAAA,KAAAA,YAAAA,GAAAA,MAAAA,KAAAA,GAAAA,KAAAA,+FAGYJ,KAAAA,WAAAA,IAAAA,EAAAA,MAAAA,CAAAA,GAAAA,YAAAA,EAAAA,OAAAA,EAAAA,KAAAA,EAAAA,GAAAA,KAAAA,OAAAA,EAAAA,IAAAA,CAAAA,EAAAA,OAAAA,MAAAA,GAAAA,CAAAA,EAAAA,QAAAA,CAAAA,CAAAA,CAAAA,EC5BnC,IAAAK,GAAA,OAAA,eAAAN,EAAA,OAAA,sBAAAtB,EAAA,OAAA,UAAA,eAAAE,EAAA,OAAA,UAAA,qBAAA5F,EAAA,CAAAT,EAAA6G,EAAA,IAAAA,KAAA7G,EAAA+H,GAAA/H,EAAA6G,EAAA,CAAA,WAAA,GAAA,aAAA,GAAA,SAAA,GAAA,MAAA,CAAA,CAAA,EAAA7G,EAAA6G,CAAA,EAAA,EAAAS,GAAA,CAAAtH,EAAA6G,IAAA,CAAA,QAAA,KAAAA,IAAAA,EAAA,CAAA,GAAAV,EAAA,KAAAU,EAAA,CAAA,GAAApG,EAAAT,EAAA,EAAA6G,EAAA,CAAA,CAAA,EAAA,GAAAY,EAAA,QAAA,KAAAA,EAAAZ,CAAA,EAAAR,EAAA,KAAAQ,EAAA,CAAA,GAAApG,EAAAT,EAAA,EAAA6G,EAAA,CAAA,CAAA,EAAA,OAAA7G,CAAA,EAAAoH,GAAA,CAAApH,EAAA6G,IAAA,CAAA,IAAA,EAAA,CAAA,EAAA,QAAAH,KAAA1G,EAAAmG,EAAA,KAAAnG,EAAA0G,CAAA,GAAAG,EAAA,QAAAH,CAAA,EAAA,IAAA,EAAAA,CAAA,EAAA1G,EAAA0G,CAAA,GAAA,GAAA1G,GAAA,MAAAyH,EAAA,QAAAf,KAAAe,EAAAzH,CAAA,EAAA6G,EAAA,QAAAH,CAAA,EAAA,GAAAL,EAAA,KAAArG,EAAA0G,CAAA,IAAA,EAAAA,CAAA,EAAA1G,EAAA0G,CAAA,GAAA,OAAA,CAAA,EA8NwBsB,MAAAA,EAAAA,MAAAA,UAAAA,KAAAA,MACxB,CAmMyBL,eAAAA,EAAAA,CAAAA,MAAAA,EAAAA,EAAAA,CAAAA,YAAAA,EAAAA,CAAAA,OAAAA,EAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,EAAAA,EAAAA,OAAAA,OAAAA,CAAAA,EAAAA,EAAAA,eAAAA,CAAAA,EAAAA,CAAAA,OAAAA,EAAAA,IAAAA,EAAAA,KAAAA,EAAAA,eAAAA,EAAAA,SAAAA,EAAAA,WAAAA,EAAAA,WAAAA,EAAAA,cAAAA,EAAAA,OAAAA,CAAAA,EAAAA,EAAAA,EAAAA,GAAAA,EAAAA,CAAAA,SAAAA,MAAAA,OAAAA,iBAAAA,WAAAA,aAAAA,aAAAA,gBAAAA,QAAAA,CAAAA,EAAAA,MAAAA,GAAAA,CAAAA,QAAAA,KAAAA,2nBAkEbM,KAAO,OAAA,OAAA,OAAA,KAAA,OAAA,IAAA,EAAA,KAAA,qBAAA,IAAA,CAAA,MAAA,CAAA,KAAA,WAAA,KAAA,SAAA,GAAA,KAAA,aAAA,CAAA,KAAA,uBAgDPA,KAAO,OAAA,OAAA,IAAA,KAAA,OAAA,KAA8BC,qBAqFgBD,IAAAA,EAAAA,KAAAA,qBAAAA,IAAAA,CAAAA,KAAAA,MAAAA,KAAAA,eAAAA,KAAAA,QAAAA,OAAAA,OAAAA,IAAAA,KAAAA,aAAAA,GAAAA,CAAAA,IAAAA,UAAAA,CAAAA,OAAAA,KAAAA,aAAAA,KAAAA,QAAAA,CAAAA,IAAAA,SAAAA,CAAAA,OAAAA,KAAAA,QAAAA,CAAAA,OAAAA,EAAAA,CAAAA,IAAAA,EAAAA,EAAAA,GAAAA,CAAAA,KAAAA,SAAAA,OAAAA,MAAAA,EAAAA,KAAAA,eAAAA,EAAAA,UAAAA,KAAAA,OAwFjDA,WAAAA,EAAAA,KAAAA,aAAAA,EAAAA,EAAAA,EAAAA,KAAAA,SAAAA,EAAAA,KAAAA,QAAAA,OAAAA,UAAAA,GAAAA,EAAAA,OAAAA,GAAAA,EAAAA,IAAAA,CAAAA,EAAAA,GAAAA,KAAAA,SAAAA,KAAAA,MAAAA,KAAAA,aAAAA,EAAAA,KAAAA,kBAAAA,CAAAA,GAAAA,EAAAA,KAAAA,SAAAA,MAAAA,EAAAA,KAAAA,IAAAA,IAAAA,KAAAA,aAAAA,KAAAA,SAAAA,KAAAA,kBAAAA,KAAAA,YAAAA,CAAAA,GAAAA,EAAAA,KAAAA,aAAAA,MAAAA,EAAAA,KAAAA,IAAAA,EAAAA,KAAAA,KAAAA,IAAAA,KAAAA,aAAAA,EAAAA,KAAAA,kBAAAA,CAAAA,EAAAA,CAAAA,cAAAA,CAAAA,KAAAA,QAAAA,KAAAA,QAAAA,KAAAA,QAAAA,OAAAA,KAAAA,aAAAA,EAAAA,QAAAA,KAAAA,MAAAA,GAAAA,CAAAA,IAAAA,YAAAA,CAAAA,OAAAA,KAAAA,WAAAA,CAAAA,IAAAA,WAAAA,EAAAA,CAAAA,IAAAA,KAAAA,cAAAA,KAAAA,YAAAA,EAAAA,CAAAA,KAAAA,aAAAA,KAAAA,sBAAAA,KAAAA,mIAKAA,KAAO,OAAA,OAAA,IAAA,KAAA,OAAA,IAAA,EAAA,KAAA,qBAAA,IAAA,CAAA,IAAA,cAAA,CAAA,OAAA,KAAA,aAAA,CAAA,IAAA,aAAAxB,EAAA,CAAA,KAAA,kBAAAA,CAAA,EAAA,KAAA,aAAA,KAAA,QAAA,OAAAA,CAAA,EAAA,KAAA,CAAA,IAAA,QAAA,CAAA,OAAA,KAAA,OAAA,CAAA,kBAAAA,EAAA,CAAA,IAAAC,EAAA,GAAAD,EAAA,GAAAA,GAAA,KAAA,YAAA,MAAA,IAAA,MAAA,4CAAA,KAAA,WAAA,SAAAA,CAAA,EAAA,EAAA,KAAA,gBAAAA,IAAA,KAAA,cAAAA,EAAA,KAAA,MAAA,IAAAC,EAAA,KAAA,gBAAA,MAAAA,EAAA,KAAA,KAAAD,CAAA,EAAA,CAAA,IAAA,aAAA,CAAA,OAAA,KAAA,QAAA,WAAA,CAAA,QAAAA,EAAA,GAAA,CAAA,KAAA,KAAA,EAAA,MAAA,QAAA,EAAAA,GAAA,KAAA,QAAA,QAAA,EAAA,MAAAC,EAAA,KAAA,KAAA,QAAAA,EAAA,KAAA,WAAAA,EAAA,KAAA,cAAAA,EAAA,KAAA,OAAAA,CAAA,CAAA,OAAA,CAAA,MAAAD,EAAA,IAAAM,EAAA,CAAA,OAAA,KAAA,QAAA,WAAA,KAAA,YAAA,KAAA,KAAA,KAAA,SAAA,KAAA,SAAA,eAAA,KAAA,eAAA,WAAA,KAAA,WAAA,cAAA,KAAA,cAAA,OAAA,KAAA,MAAA,CAAA,EAAA,OAAAN,EAAA,MAAA,GAAAA,CAAA,CAAA,EAAAM,EAAA,eAAA,CAAA,IAAA,GAAA,KAAA,GAAA,eAAA,EAAA,SAAA,GAAA,WAAA,GAAA,WAAA,KAAA,cAAA,KAAA,OAAA,IAAA,EAAA,IAAAS,GAAAT,ECjsBvBoB,YAAW,WAAA,IAAAtB,CAAA","x_google_ignoreList":[0,1,2,3,4,5]}